[{"text": "Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing , pages 6045\u20136051 , Hong Kong , China , November 3\u20137 , 2019 .", "entities": []}, {"text": "c", "entities": []}, {"text": "2019 Association for Computational Linguistics6045Clause - Wise and Recursive Decoding for Complex and Cross - Domain Text - to - SQL Generation Dongjun Lee SAP Labs Korea dongjun.lee01@sap.com", "entities": [[16, 21, "TaskName", "Text - to - SQL"]]}, {"text": "Abstract Most deep learning approaches for text - toSQL generation are limited to the WikiSQL dataset , which only supports very simple queries over a single table .", "entities": [[14, 15, "DatasetName", "WikiSQL"]]}, {"text": "We focus on theSpider dataset , a complex and crossdomain text - to - SQL task , which includes complex queries over multiple tables .", "entities": [[10, 15, "TaskName", "text - to - SQL"]]}, {"text": "In this paper , we propose a SQL clause - wise decoding neural architecture with a self - attention based database schema encoder to address the Spidertask .", "entities": []}, {"text": "Each of the clause - speci\ufb01c decoders consists of a set of sub - modules , which is de\ufb01ned by the syntax of each clause .", "entities": []}, {"text": "Additionally , our model works recursively to support nested queries .", "entities": []}, {"text": "When evaluated on the Spider dataset , our approach achieves 4.6 % and 9.8 % accuracy gain in the test and dev sets , respectively .", "entities": [[15, 16, "MetricName", "accuracy"]]}, {"text": "In addition , we show that our model is signi\ufb01cantly more effective at predicting complex and nested queries than previous work .", "entities": []}, {"text": "1 Introduction Text - to - SQL generation is the task of translating a natural language question into the corresponding SQL .", "entities": [[2, 7, "TaskName", "Text - to - SQL"]]}, {"text": "Recently , various deep learning approaches have been proposed based on the WikiSQL dataset ( Zhong et al . , 2017 ) .", "entities": [[12, 13, "DatasetName", "WikiSQL"]]}, {"text": "However , because WikiSQL contains only very simple queries over just a single table , these approaches ( Xu et al . , 2017 ; Huang et al . , 2018 ; Yu et al . , 2018a ; Dong and Lapata , 2018 ) can not be applied directly to generate complex queries containing elements such as JOIN , GROUP BY , and nested queries .", "entities": [[3, 4, "DatasetName", "WikiSQL"]]}, {"text": "To overcome this limitation , Yu et al .", "entities": []}, {"text": "( 2018c ) introduced Spider , a new complex and crossdomain text - to - SQL dataset .", "entities": [[11, 16, "TaskName", "text - to - SQL"]]}, {"text": "It contains a large number of complex queries over different databases with multiple tables .", "entities": []}, {"text": "It also requires a model to generalize to unseen database schema as different databases are used for training and testing .", "entities": []}, {"text": "Therefore , a model should understand notonly the natural language question but also the schema of the corresponding database to predict the correct SQL query .", "entities": []}, {"text": "In this paper , we propose a novel SQL - speci\ufb01c clause - wise decoding neural network model to address the Spider task .", "entities": []}, {"text": "We \ufb01rst predict a sketch for each SQL clause ( e.g. , SELECT , WHERE ) with text classi\ufb01cation modules .", "entities": []}, {"text": "Then , clause - speci\ufb01c decoders \ufb01nd the columns and corresponding operators based on the sketches .", "entities": []}, {"text": "Our contributions are summarized as follows .", "entities": []}, {"text": "\u000fWe decompose the clause - wise SQL decoding process .", "entities": []}, {"text": "We also modularize each of the clause - speci\ufb01c decoders into sub - modules based on the syntax of each clause .", "entities": []}, {"text": "Our architecture enables the model to learn clausedependent context and also ensures the syntactic correctness of the predicted SQL .", "entities": []}, {"text": "\u000fOur model works recursively so that it can predict nested queries .", "entities": []}, {"text": "\u000fWe also introduce a self - attention based database schema encoder that enables our model to generalize to unseen databases .", "entities": []}, {"text": "In the experiment on the Spider dataset , we achieve 24.3 % and 28.8 % exact SQL matching accuracy on the test and dev set respectively , which outperforms the previous state - of - the - art approach ( Yu et al . , 2018b ) by 4.6 % and 9.8 % .", "entities": [[18, 19, "MetricName", "accuracy"]]}, {"text": "In addition , we show that our approach is signi\ufb01cantly more effective compared to previous work at predicting not only simple SQL queries , but also complex and nested queries .", "entities": []}, {"text": "2 Related Work Our work is related to the grammar - based constrained decoding approaches for semantic parsing ( Yin and Neubig , 2017 ; Rabinovich et al . , 2017 ;", "entities": [[16, 18, "TaskName", "semantic parsing"]]}, {"text": "6046Iyer et al . , 2018 ) .", "entities": []}, {"text": "While their approaches are focused on general purpose code generation , we instead focus on SQL - speci\ufb01c grammar to address the text - to - SQL task .", "entities": [[8, 10, "TaskName", "code generation"], [22, 27, "TaskName", "text - to - SQL"]]}, {"text": "Our task differs from code generation in two aspects .", "entities": [[4, 6, "TaskName", "code generation"]]}, {"text": "First , it takes a database schema as an input in addition to natural language .", "entities": []}, {"text": "To predict SQL correctly , a model should fully understand the relationship between the question and the schema .", "entities": []}, {"text": "Second , as SQL is a non - procedural language , predictions of SQL clauses do not need to be done sequentially .", "entities": []}, {"text": "For text - to - SQL generation , several SQLspeci\ufb01c approaches have been proposed ( Zhong et al . , 2017 ; Xu et", "entities": [[1, 6, "TaskName", "text - to - SQL"]]}, {"text": "al . , 2017 ; Huang et al . , 2018 ; Yu et al . , 2018a ; Dong and Lapata , 2018 ; Yavuz et al . , 2018 ) based on WikiSQL dataset ( Zhong et al . , 2017 )", "entities": [[34, 35, "DatasetName", "WikiSQL"]]}, {"text": ".", "entities": []}, {"text": "However , all of them are limited to the speci\ufb01c WikiSQL SQL sketch , which only supports very simple queries .", "entities": [[10, 11, "DatasetName", "WikiSQL"]]}, {"text": "It includes only the SELECT andWHERE clauses , only a single expression in the SELECT clause , and works only for a single table .", "entities": []}, {"text": "To predict more complex SQL queries , sequence - to - sequence ( Iyer et al . , 2017 ; Finegan - Dollak et al . , 2018 ) and template - based ( Finegan - Dollak et al . , 2018 ; Lee et al . , 2019 ) approaches have been proposed .", "entities": []}, {"text": "However , they focused only on speci\ufb01c databases such as ATIS ( Price , 1990 ) and GeoQuery ( Zelle and Mooney , 1996 ) .", "entities": [[10, 11, "DatasetName", "ATIS"]]}, {"text": "Because they only considered question and SQL pairs without requiring an understanding of database schema , their approaches can not generalize to unseen databases .", "entities": []}, {"text": "SyntaxSQLNet ( Yu et al . , 2018b ) is the \ufb01rst and state - of - the - art model for the Spider ( Yu et al . , 2018c ) , a complex and cross - domain text - to - SQL task .", "entities": [[39, 44, "TaskName", "text - to - SQL"]]}, {"text": "They proposed an SQL speci\ufb01c syntax tree - based decoder with SQL generation history .", "entities": []}, {"text": "Our approach differs from their model in the following aspects .", "entities": []}, {"text": "First , taking into account that SQL corresponds to non - procedural language , we develop a clause - speci\ufb01c decoder for each SQL clause , where SyntaxSQLNet predicts SQL tokens sequentially .", "entities": []}, {"text": "For example , in SyntaxSQLNet , a single column prediction module works both in the SELECT andWHERE clauses , depending on the SQL decoding history .", "entities": []}, {"text": "In contrast , we de\ufb01ne and train decoding modules separately for each SQL clause to fully utilize clausedependent context .", "entities": []}, {"text": "Second , we apply sequenceto - sequence architecture to predict columns instead of using the sequence - to - set framework from Figure 1 : Clause - wise and recursive SQL generation process .", "entities": []}, {"text": "SyntaxSQLNet , because correct ordering is essential for the GROUP BY andORDER BY clauses .", "entities": []}, {"text": "Finally , we introduce a self - attention mechanism ( Lin et al . , 2017 ) to ef\ufb01ciently encode database schema , which includes multiple tables .", "entities": []}, {"text": "3", "entities": []}, {"text": "Methodology We predict complex SQL clause - wisely as described in Figure 1 .", "entities": []}, {"text": "Each clause is predicted consecutively by at most three different types of modules ( sketch , column , operator ) .", "entities": []}, {"text": "The same architecture recursively predicts nested queries with temporal predicted SQL as an additional input .", "entities": []}, {"text": "3.1 Question and Schema Encoding We encode a natural language question with a bidirectional LSTM .", "entities": [[13, 15, "MethodName", "bidirectional LSTM"]]}, {"text": "We denote HQ2Rd\u0002jXjas the question encoding , where dis the number of LSTM units andjXjis the number of tokens in the question .", "entities": [[12, 13, "MethodName", "LSTM"]]}, {"text": "To encode a database schema , we consider each column in its tables as a concatenated sequence of words from the table name and column name with a separation token .", "entities": []}, {"text": "( e.g. , [ student , [ SEP ] , \ufb01rst , name ] ) .", "entities": []}, {"text": "First , we apply bi - directional LSTM over this sequence for each column .", "entities": [[7, 8, "MethodName", "LSTM"]]}, {"text": "Then , we apply the self - attention mechanism ( Lin et al . , 2017 ) over the LSTM outputs to form a summarized \ufb01xedsize vector for each column .", "entities": [[19, 20, "MethodName", "LSTM"]]}, {"text": "For the ith column , its encoding h(i ) col2Rdis computed by a weighted sum of the LSTM output o(i ) col2Rd\u0002jLjas follows : \u000b = softmax ( wTtanh ( o(i ) col ) ) ( 1 ) h(i ) col = o(i ) col \u000b T(2 ) wherejLjis the number of tokens in the column andw2Rdis a trainable parameter .", "entities": [[17, 18, "MethodName", "LSTM"], [26, 27, "MethodName", "softmax"]]}, {"text": "We denote Hcol=", "entities": []}, {"text": "[ h(1 ) col;:::h(jCj ) col]as columns encoding where jCjis the number of columns in the database .", "entities": []}, {"text": "60473.2 Sketch Prediction We predict the clause - wise sketch via 8 different text classi\ufb01cation modules that include the number of SQL expressions in each clause , the presence of LIMIT clause , and the presence of INTERSECT / UNION / EXCEPT as described in Figure 1 .", "entities": [[1, 2, "DatasetName", "Sketch"]]}, {"text": "All of them share the same model architecture but are trained separately .", "entities": []}, {"text": "For the classi\ufb01cation , we applied attention - based bi - directional LSTM following Zhou et", "entities": [[12, 13, "MethodName", "LSTM"]]}, {"text": "al . ( 2016 ) .", "entities": []}, {"text": "First , we compute sentence representation rs2 Rdby a weighted sum of question encoding HQ2 Rd\u0002jXj .", "entities": []}, {"text": "Then we apply the softmax classi\ufb01er to choose the sketch as follows : \u000b s = softmax ( wT stanh ( HQ ) ) ( 3 ) rs = HQ \u000b T s ( 4 ) Psketch = softmax ( Wsrs+bs ) ( 5 ) wherews2Rd;Ws2Rns\u0002d;bs2Rnsare trainable parameters and nsis the number of possible sketches .", "entities": [[4, 5, "MethodName", "softmax"], [16, 17, "MethodName", "softmax"], [38, 39, "MethodName", "softmax"]]}, {"text": "3.3 Columns and Operators Prediction To predict columns and operators , we use the LSTM decoder with the attention mechanism ( Luong et al . , 2015 ) such that the number of decoding steps are decided by the sketch prediction module .", "entities": [[14, 15, "MethodName", "LSTM"]]}, {"text": "We train 5 different column prediction modules separately for each SQL clause , but they share the same architecture .", "entities": []}, {"text": "In the column prediction module , the hidden state of the decoder at the t - th decoding step is computed as d(t ) col(2Rd )", "entities": []}, {"text": "= LSTM ( d(t\u00001 ) col;h(t\u00001 ) col ) , whereh(t\u00001 ) col2Rdis an encoding of the predicted column in the previous decoding step .", "entities": [[1, 2, "MethodName", "LSTM"]]}, {"text": "The context vectorr(t)is computed by a weighted sum of question encodings HQ2Rd\u0002jXjbased on attention weight as follows : \u000b ( t)=softmax ( d(t ) colTHQ ) ( 6 ) r(t)=HQ \u000b ( t)T(7 ) Then , the attentional output of the t - th decoding stepa(t ) colis computed as a linear combination of d(t ) col2Rdandr(t)2Rdfollowed by tanh activation .", "entities": [[58, 60, "MethodName", "tanh activation"]]}, {"text": "a(t ) col = tanh ( W1d(t ) col+W2r(t ) ) ( 8)whereW1;W 22Rd\u0002dare trainable parameters .", "entities": []}, {"text": "Finally , the probability for each column at the tth decoding step is computed as a dot product betweena(t ) col2Rdand the encoding of each column inHcol2Rd\u0002jCjfollowed by softmax .", "entities": [[28, 29, "MethodName", "softmax"]]}, {"text": "P(t )", "entities": []}, {"text": "col = softmax ( a(t ) colTHcol ) ( 9 ) To predict corresponding operators for each predicted column , we use a decoder of the same architecture as in the column prediction module .", "entities": [[2, 3, "MethodName", "softmax"]]}, {"text": "The only difference is that a decoder input at the t - th decoding step is an encoding of the t - th predicted column from the column prediction module .", "entities": []}, {"text": "d(t ) op = LSTM ( d(t\u00001 ) op;h(t ) col ) ( 10 ) Attentional output a(t ) op2Rdis computed identically to Eq .", "entities": [[4, 5, "MethodName", "LSTM"]]}, {"text": "( 8) .", "entities": []}, {"text": "Then , the probability for operators corresponding to the t - th predicted column is computed by the softmax classi\ufb01er as follows : P(t ) op = softmax ( Woa(t ) op+bo ) ( 11 ) whereWo2Rno\u0002dandbo2Rnoare trainable parameters and nois the number of possible operators .", "entities": [[18, 19, "MethodName", "softmax"], [27, 28, "MethodName", "softmax"]]}, {"text": "3.4 From Clause Prediction After the predictions of all the other clauses , we use a heuristic to generate the FROM clause .", "entities": []}, {"text": "We \ufb01rst collect all the columns that appear in the predicted SQL , and then we JOIN tables that include these predicted columns .", "entities": []}, {"text": "3.5 Recursion for Nested Queries To predict the presence of a sub - query , we train another module that has the same architecture as the operator prediction module .", "entities": []}, {"text": "Instead of predicting corresponding operators for each column , it predicts whether each column is compared to a variable ( e.g. , WHERE age>3 ) or to a sub - query ( e.g. , WHERE age>(SELECT avg ( age ) .. ) ) .", "entities": []}, {"text": "In the latter case , we add the temporal [ SUB QUERY ] token to the corresponding location in the SQL output .", "entities": []}, {"text": "Additionally , if the sketch prediction module predicts one of INTERSECT / UNION / EXCEPT operators , we add a [ SUB QUERY ] token after the operator .", "entities": []}, {"text": "To predict a sub - query , our model takes the temporal generated SQL with a [ SUB QUERY ] token as an input in addition to a natural language question with separate token [ SEP ] ( e.g. ,", "entities": []}, {"text": "6048Dev Test Method Easy Medium Hard Extra Hard All All SQLNet 23.2 % 8.6 % 9.8 % 0 % 10.9 % 12.4 % TypeSQL 18.8 % 5.5 % 4.6 % 2.4 % 8.0 % 8.2 % SyntaxSQLNet 38.4 % 15.0 % 16.1 % 3.5 % 19.0 % 19.7 % Ours 53.2 % 27.0 % 20.1 % 6.5 % 28.8 % 24.3 % -rec 53.2 % 27.0 % 14.4 % 2.9 % 27.4 % -rec - col - att 46.4 % 22.0 % 12.1 % 4.7 % 23.4 % -rec -col - att -sketch 33.2 % 18.6 % 11.5 % 4.7 % 18.7 % Table 1 : Accuracy of exact SQL matching with different hardness levels .", "entities": [[17, 18, "DatasetName", "0"], [106, 107, "MetricName", "Accuracy"]]}, {"text": "Method SELECT WHERE GROUP", "entities": []}, {"text": "BY ORDER BY KEYWORDS SQLNet 46.6 % 20.6 % 37.6 % 49.2 % 62.8 % TypeSQL 43.7 % 14.8 % 16.9 % 52.1 % 67.0 % SyntaxSQLNet 55.4 % 22.2 % 51.4 % 50.6 % 73.3 % Ours 68.7 % 39.0 % 63.1 % 63.5 % 76.5 % Table 2 : F1 scores of SQL component matching on the devset .", "entities": [[51, 52, "MetricName", "F1"]]}, {"text": "What is ...", "entities": []}, {"text": "[ SEP ] SELECT ... INTERSECT [ SUB QUERY ] ) .", "entities": []}, {"text": "This input is encoded in the same way as question encoding described in Section 3.1 .", "entities": []}, {"text": "Then , the rest of the SQL generation process is identical to that described in Section 3.2 \u2013 3.4 .", "entities": []}, {"text": "After the sub - query is predicted , it replaces the[SUB QUERY ] token to form the \ufb01nal query .", "entities": []}, {"text": "4 Experiments 4.1 Experimental Setup We evaluate our model with Spider ( Yu et al . , 2018c ) , a large - scale , complex and cross - domain text - to - SQL dataset .", "entities": [[30, 35, "TaskName", "text - to - SQL"]]}, {"text": "We follow the same database split as Yu et al .", "entities": []}, {"text": "( 2018c ) , which ensures that any database schema that appears in the training set does not appear in the dev or test set .", "entities": []}, {"text": "Through this split , we examine how well our model can be generalized to unseen databases .", "entities": []}, {"text": "Because the test set is not opened to the public , we use the devset for the ablation analysis .", "entities": []}, {"text": "For the evaluation metrics , we use 1 ) accuracy of exact SQL matching and 2 ) F1 score of SQL component matching , proposed by ( Yu et al . , 2018c ) .", "entities": [[9, 10, "MetricName", "accuracy"], [17, 19, "MetricName", "F1 score"]]}, {"text": "We also follow their query hardness criteria to understand the model performance on different levels of queries .", "entities": []}, {"text": "Our model and all the baseline models are trained based on only the Spider dataset without data augmentation .", "entities": [[16, 18, "TaskName", "data augmentation"]]}, {"text": "4.2 Model Con\ufb01guration We use the same hyperparameters for every module .", "entities": []}, {"text": "For the word embedding , we apply deep contextualized word representations ( ELMO ) from Peters et al .", "entities": [[12, 13, "MethodName", "ELMO"]]}, {"text": "( 2018 ) and allow them to be \ufb01ne - tunedduring the training .", "entities": []}, {"text": "For the question and column encoders , we use a 1 - layer 512 - unit bi - directional LSTM .", "entities": [[19, 20, "MethodName", "LSTM"]]}, {"text": "For the decoders in the columns and operators prediction modules , we use a 1 - layer 1024unit uni - directional LSTM .", "entities": [[21, 22, "MethodName", "LSTM"]]}, {"text": "For the training , we use Adam optimizer ( Kingma and Ba , 2014 ) with a learning rate of 1e-4 and use early stopping with 50 epochs .", "entities": [[6, 7, "MethodName", "Adam"], [7, 8, "HyperparameterName", "optimizer"], [17, 19, "HyperparameterName", "learning rate"], [23, 25, "MethodName", "early stopping"]]}, {"text": "Additionally , we use dropout ( Hinton et al . , 2012 ) with a rate of 0.2 for the regularization .", "entities": []}, {"text": "4.3 Result and Analysis Table 1 shows the exact SQL matching accuracy of our model and previous models .", "entities": [[11, 12, "MetricName", "accuracy"]]}, {"text": "We achieve 24.3 % and 28.8 % on the test and dev sets respectively , which outperforms the previous best model SyntaxSQLNet ( Yu et al . , 2018b ) by 4.6 % and 9.8 % .", "entities": []}, {"text": "Moreover , our model outperforms previous models on all different query hardness levels .", "entities": []}, {"text": "To examine how each technique contributes to the performance , we conduct an ablation analysis of three aspects : 1 ) without recursion , 2 ) without self - attention for database schema encoding , and 3 ) without sketch prediction modules that decide the number of decoding steps .", "entities": []}, {"text": "Without recursive sub - query generation , the accuracy drops by 5.7 % and 3.6 % for hard and extra hard queries , respectively .", "entities": [[8, 9, "MetricName", "accuracy"]]}, {"text": "This result shows that the recursion we use enables the model to predict nested queries .", "entities": []}, {"text": "When using the \ufb01nal LSTM hidden state as in Yu et al . ( 2018b ) instead of using self - attention for schema encoding , the accuracy drops by 4.0 % on all queries .", "entities": [[4, 5, "MethodName", "LSTM"], [27, 28, "MetricName", "accuracy"]]}, {"text": "Finally , when using only an encoder-", "entities": []}, {"text": "6049decoder architecture without sketch generation for columns prediction , the accuracy drops by 4.7 % .", "entities": [[10, 11, "MetricName", "accuracy"]]}, {"text": "For the component matching result for each SQL clause , our model outperforms previous approaches for all of the SQL components by a signi\ufb01cant margin , as shown in Table 2 .", "entities": []}, {"text": "Examples of predicted SQL from different models are shown in Appendix A. 5 Conclusion In this paper , we propose a recursive and SQL clause - wise decoding neural architecture to address the complex and cross - domain text - to - SQL task .", "entities": [[38, 43, "TaskName", "text - to - SQL"]]}, {"text": "We evaluate our model with the Spider dataset , and the experimental result shows that our model signi\ufb01cantly outperforms previous work for generating not only simple queries , but also complex and nested queries .", "entities": []}, {"text": "Acknowledgments We thank Yongsik Lee , Jaesik Yoon , and Donghun Lee ( SAP ) for their reviews and support .", "entities": []}, {"text": "We also thank professor Sungroh Yoon , Jongyun Song , and Taeuk Kim ( Seoul National University ) for their insightful feedback and three anonymous reviewers for their helpful comments .", "entities": []}, {"text": "References Li Dong and Mirella Lapata .", "entities": []}, {"text": "2018 .", "entities": []}, {"text": "Coarse - to-\ufb01ne decoding for neural semantic parsing .", "entities": [[6, 8, "TaskName", "semantic parsing"]]}, {"text": "In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics ( Volume 1 : Long Papers ) , volume 1 , pages 731\u2013742 .", "entities": []}, {"text": "Catherine Finegan - Dollak , Jonathan K Kummerfeld , Li Zhang , Karthik Ramanathan , Sesh Sadasivam , Rui Zhang , and Dragomir Radev .", "entities": []}, {"text": "2018 .", "entities": []}, {"text": "Improving text - to - sql evaluation methodology .", "entities": [[1, 6, "TaskName", "text - to - sql"]]}, {"text": "In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics ( Volume 1 : Long Papers ) , volume 1 , pages 351\u2013360 .", "entities": []}, {"text": "Geoffrey E Hinton , Nitish Srivastava , Alex Krizhevsky , Ilya Sutskever , and Ruslan R Salakhutdinov .", "entities": [[14, 15, "DatasetName", "Ruslan"]]}, {"text": "2012 .", "entities": []}, {"text": "Improving neural networks by preventing coadaptation of feature detectors .", "entities": []}, {"text": "arXiv preprint arXiv:1207.0580 .", "entities": [[0, 1, "DatasetName", "arXiv"]]}, {"text": "Po - Sen Huang , Chenglong Wang , Rishabh Singh , Wen - tau Yih , and Xiaodong He .", "entities": []}, {"text": "2018 .", "entities": []}, {"text": "Natural language to structured query generation via metalearning .", "entities": []}, {"text": "In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics : Human Language Technologies , Volume 2 ( Short Papers ) , volume 2 , pages 732\u2013738.Srinivasan Iyer , Ioannis Konstas , Alvin Cheung , Jayant Krishnamurthy , and Luke Zettlemoyer .", "entities": []}, {"text": "2017 .", "entities": []}, {"text": "Learning a neural semantic parser from user feedback .", "entities": []}, {"text": "arXiv preprint arXiv:1704.08760 .", "entities": [[0, 1, "DatasetName", "arXiv"]]}, {"text": "Srinivasan Iyer , Ioannis Konstas , Alvin Cheung , and Luke Zettlemoyer .", "entities": []}, {"text": "2018 .", "entities": []}, {"text": "Mapping language to code in programmatic context .", "entities": []}, {"text": "In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing , pages 1643\u20131652 .", "entities": []}, {"text": "Diederik P Kingma and Jimmy Ba . 2014 .", "entities": []}, {"text": "Adam : A method for stochastic optimization .", "entities": [[0, 1, "MethodName", "Adam"], [5, 7, "TaskName", "stochastic optimization"]]}, {"text": "arXiv preprint arXiv:1412.6980 .", "entities": [[0, 1, "DatasetName", "arXiv"]]}, {"text": "Dongjun Lee , Jaesik Yoon , Jongyun Song , Sanggil Lee , and Sungroh Yoon .", "entities": []}, {"text": "2019 .", "entities": []}, {"text": "One - shot learning for text - to - sql generation .", "entities": [[0, 4, "TaskName", "One - shot learning"], [5, 10, "TaskName", "text - to - sql"]]}, {"text": "arXiv preprint arXiv:1905.11499 .", "entities": [[0, 1, "DatasetName", "arXiv"]]}, {"text": "Zhouhan Lin , Minwei Feng , Cicero Nogueira dos Santos , Mo Yu , Bing Xiang , Bowen Zhou , and Yoshua Bengio .", "entities": []}, {"text": "2017 .", "entities": []}, {"text": "A structured self - attentive sentence embedding .", "entities": [[5, 7, "TaskName", "sentence embedding"]]}, {"text": "arXiv preprint arXiv:1703.03130 .", "entities": [[0, 1, "DatasetName", "arXiv"]]}, {"text": "Thang Luong , Hieu Pham , and Christopher D Manning .", "entities": []}, {"text": "2015 .", "entities": []}, {"text": "Effective approaches to attention - based neural machine translation .", "entities": [[7, 9, "TaskName", "machine translation"]]}, {"text": "In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing , pages 1412\u20131421 .", "entities": []}, {"text": "Matthew Peters , Mark Neumann , Mohit Iyyer , Matt Gardner , Christopher Clark , Kenton Lee , and Luke Zettlemoyer .", "entities": []}, {"text": "2018 .", "entities": []}, {"text": "Deep contextualized word representations .", "entities": []}, {"text": "In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics : Human Language Technologies , Volume 1 ( Long Papers ) , volume 1 , pages 2227\u20132237 .", "entities": []}, {"text": "Patti J Price .", "entities": []}, {"text": "1990 .", "entities": []}, {"text": "Evaluation of spoken language systems : The atis domain .", "entities": [[7, 8, "DatasetName", "atis"]]}, {"text": "In Speech and Natural Language : Proceedings of a Workshop Held at Hidden Valley , Pennsylvania , June 24 - 27 , 1990 .", "entities": []}, {"text": "Maxim Rabinovich , Mitchell Stern , and Dan Klein . 2017 .", "entities": []}, {"text": "Abstract syntax networks for code generation and semantic parsing .", "entities": [[4, 6, "TaskName", "code generation"], [7, 9, "TaskName", "semantic parsing"]]}, {"text": "In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics ( Volume 1 : Long Papers ) , pages 1139\u20131149 .", "entities": []}, {"text": "Xiaojun Xu , Chang Liu , and Dawn Song . 2017 .", "entities": []}, {"text": "Sqlnet :", "entities": []}, {"text": "Generating structured queries from natural language without reinforcement learning .", "entities": []}, {"text": "arXiv preprint arXiv:1711.04436 .", "entities": [[0, 1, "DatasetName", "arXiv"]]}, {"text": "Semih Yavuz , Izzeddin Gur , Yu Su , and Xifeng Yan .", "entities": []}, {"text": "2018 .", "entities": []}, {"text": "What it takes to achieve 100 % condition accuracy on wikisql .", "entities": [[8, 9, "MetricName", "accuracy"], [10, 11, "DatasetName", "wikisql"]]}, {"text": "In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing , pages 1702\u20131711 .", "entities": []}, {"text": "Pengcheng Yin and Graham Neubig .", "entities": []}, {"text": "2017 .", "entities": []}, {"text": "A syntactic neural model for general - purpose code generation .", "entities": [[8, 10, "TaskName", "code generation"]]}, {"text": "InProceedings of the 55th Annual Meeting of the", "entities": []}, {"text": "6050Association for Computational Linguistics ( Volume 1 : Long Papers ) , pages 440\u2013450 .", "entities": []}, {"text": "Tao Yu , Zifan Li , Zilin Zhang , Rui Zhang , and Dragomir Radev . 2018a .", "entities": []}, {"text": "Typesql :", "entities": []}, {"text": "Knowledgebased type - aware neural text - to - sql generation .", "entities": [[5, 10, "TaskName", "text - to - sql"]]}, {"text": "In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics : Human Language Technologies , Volume 2 ( Short Papers ) , volume 2 , pages 588\u2013594 .", "entities": []}, {"text": "Tao Yu , Michihiro Yasunaga , Kai Yang , Rui Zhang , Dongxu Wang , Zifan Li , and Dragomir Radev . 2018b .", "entities": []}, {"text": "Syntaxsqlnet :", "entities": []}, {"text": "Syntax tree networks for complex and cross - domain text - to - sql task .", "entities": [[9, 14, "TaskName", "text - to - sql"]]}, {"text": "In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing , pages 1653\u20131663 .", "entities": []}, {"text": "Tao Yu , Rui Zhang , Kai Yang , Michihiro Yasunaga , Dongxu Wang , Zifan Li , James Ma , Irene Li , Qingning Yao , Shanelle Roman , et al . 2018c .", "entities": []}, {"text": "Spider :", "entities": []}, {"text": "A large - scale human - labeled dataset for complex and cross - domain semantic parsing and text - to - sql task .", "entities": [[14, 16, "TaskName", "semantic parsing"], [17, 22, "TaskName", "text - to - sql"]]}, {"text": "InProceedings of the 2018 Conference on Empirical Methods in Natural Language Processing , pages 3911\u20133921 .", "entities": []}, {"text": "John M Zelle and Raymond J Mooney .", "entities": []}, {"text": "1996 .", "entities": []}, {"text": "Learning to parse database queries using inductive logic programming .", "entities": [[6, 9, "TaskName", "inductive logic programming"]]}, {"text": "In Proceedings of the national conference on arti\ufb01cial intelligence , pages 1050\u20131055 .", "entities": []}, {"text": "Victor Zhong , Caiming Xiong , and Richard Socher .", "entities": []}, {"text": "2017 . Seq2sql :", "entities": []}, {"text": "Generating structured queries from natural language using reinforcement learning .", "entities": []}, {"text": "CoRR , abs/1709.00103 .", "entities": []}, {"text": "Peng Zhou , Wei Shi , Jun Tian , Zhenyu Qi , Bingchen Li , Hongwei Hao , and Bo Xu .", "entities": []}, {"text": "2016 .", "entities": []}, {"text": "Attentionbased bidirectional long short - term memory networks for relation classi\ufb01cation .", "entities": [[2, 7, "MethodName", "long short - term memory"]]}, {"text": "In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics ( Volume 2 : Short Papers ) , volume 2 , pages 207\u2013212 .", "entities": []}, {"text": "A Sample SQL Predictions In Table 3 , we show some examples of predicted SQL queries from different models .", "entities": []}, {"text": "We compare the result of our model with two of previous state - of - the - art models : SyntaxSQLNet ( Yu et al . , 2018b ) and the modi\ufb01ed version of SQLNet ( Xu et", "entities": []}, {"text": "al . , 2017 ) by Yu et al .", "entities": []}, {"text": "( 2018c ) to support complex SQL queries .", "entities": []}, {"text": "6051hardness type description easy NL", "entities": []}, {"text": "What are the names of all the countries that became independent after 1950 ?", "entities": []}, {"text": "Truth SELECT Name FROM country", "entities": []}, {"text": "WHERE IndepYear >", "entities": []}, {"text": "1950", "entities": []}, {"text": "Ours SELECT Name FROM country", "entities": []}, {"text": "WHERE IndepYear >", "entities": []}, {"text": "\u201c [ V AR ] \u201d", "entities": []}, {"text": "Syntax SELECT Name FROM country", "entities": []}, {"text": "WHERE GovernmentForm", "entities": []}, {"text": "= \u201c [ V AR ] \u201d", "entities": []}, {"text": "SQLNet SELECT T1.Name FROM cityasT1JOIN country asT2WHERE T2.Population > \u201c [ V AR ] \u201d medium NL Which city and country is the Alton airport at ?", "entities": []}, {"text": "Truth SELECT City , Country FROM airports WHERE AirportName = \u201c Alton \u201d Ours SELECT City , Country FROM airports", "entities": []}, {"text": "WHERE AirportName", "entities": []}, {"text": "= \u201c [ V AR ] \u201d", "entities": []}, {"text": "Syntax SELECT Country , City FROM airports WHERE Country = \u201c [ V AR ] \u201d", "entities": []}, {"text": "SQLNet SELECT T1.City , T2.DestAirport FROM airports asT1JOIN \ufb02ights asT2 medium NL List the names of poker players ordered by the \ufb01nal tables made in ascending order .", "entities": []}, {"text": "Truth SELECT T1.Name FROM people asT1JOIN poker player asT2ORDER BY T2.Final Table Made OursSELECT T1.Name", "entities": []}, {"text": "FROM people asT1JOIN poker player asT2ORDER BY T2.Final Table Made ASC Syntax SELECT T2.Name FROM poker player asT1JOIN people asT2ORDER BY T1.Earnings ASC SQLNet SELECT Name FROM people ORDER BY Birth DateASC medium NL", "entities": []}, {"text": "How much does the most recent treatment cost ?", "entities": []}, {"text": "Truth SELECT cost oftreatment FROM Treatments ORDER BY date oftreatment DESC LIMIT 1 Ours SELECT cost oftreatment FROM Treatments ORDER", "entities": []}, {"text": "BY cost oftreatment DESC LIMIT", "entities": []}, {"text": "\u201c [ V AR ] \u201d", "entities": []}, {"text": "Syntax SELECT cost oftreatment FROM Treatments ORDER BY cost oftreatment ASC LIMIT \u201c [ V AR ] \u201d", "entities": []}, {"text": "SQLNetSELECT T1.charge amount FROM Charges asT1JOIN Dogs asT2ORDER BY date adopted DESC LIMIT \u201c [ V AR ] \u201d hard NL List the names of teachers who have not been arranged to teach courses .", "entities": []}, {"text": "TruthSELECT Name FROM teacher WHERE Teacher idNOT IN ( SELECT Teacher idFROM course arrange )", "entities": []}, {"text": "OursSELECT Name FROM teacher WHERE Teacher idNOT IN ( SELECT Teacher idFROM course arrange )", "entities": []}, {"text": "Syntax SELECT Name FROM teacher SQLNet SELECT Name FROM teacher hard NL", "entities": []}, {"text": "Which cities do more than one employee under age 30 come from ?", "entities": []}, {"text": "Truth SELECT cityFROM employee WHERE age<30GROUP BY cityHAVING count ( * ) >", "entities": []}, {"text": "1 Ours SELECT cityFROM employee WHERE age<\u201c[V", "entities": []}, {"text": "AR ] \u201d GROUP BY cityHAVING count ( * ) >", "entities": []}, {"text": "\u201c [ V AR ] \u201d", "entities": []}, {"text": "Syntax SELECT cityFROM employee WHERE age>\u201c[V AR ] \u201d", "entities": []}, {"text": "SQLNetSELECT T1.city FROM employee asT1JOIN hiring asT2JOIN shopasT3WHERE T3.District > \u201c [ V AR ] \u201d GROUP BY T1.city HAVING count ( * ) >", "entities": []}, {"text": "\u201c [ V AR ] \u201d", "entities": []}, {"text": "hard NL", "entities": []}, {"text": "What is the document", "entities": []}, {"text": "i d with least number of paragraphs ?", "entities": []}, {"text": "Truth SELECT document idFROM Paragraphs GROUP BY document idORDER BY count ( * )", "entities": []}, {"text": "LIMIT 1 OursSELECT document idFROM Documents GROUP", "entities": []}, {"text": "BY document idORDER BY count ( * ) ASC LIMIT", "entities": []}, {"text": "\u201c [ V AR ] \u201d SyntaxSELECT document idFROM Documents GROUP", "entities": []}, {"text": "BY document idORDER BY count ( * ) ASC LIMIT", "entities": []}, {"text": "\u201c [ V AR ] \u201d", "entities": []}, {"text": "HAVING count ( * ) >", "entities": []}, {"text": "= \u201c [ V AR ] \u201d SQLNetSELECT template idFROM Templates GROUP", "entities": []}, {"text": "BY template idHAVING sum ( * ) NOT \u201c [ V AR ] \u201d ORDER BY count ( * ) ASC LIMIT", "entities": []}, {"text": "\u201c", "entities": []}, {"text": "[ V AR ] \u201d extra NL How many dogs have not gone through any treatment ?", "entities": []}, {"text": "Truth SELECT count ( * ) FROM Dogs WHERE dogidNOT IN ( SELECT dogidFROM Treatments )", "entities": []}, {"text": "Ours SELECT count ( * ) FROM Dogs WHERE dogidNOT IN ( SELECT dogidFROM Treatments ) Syntax SELECT count ( * ) FROM Charges WHERE charge idNOT IN ( SELECT charge idFROM Charges ) SQLNet SELECT count ( * ) FROM Dogs WHERE dogidIN\u201c[V", "entities": []}, {"text": "AR ] \u201d", "entities": []}, {"text": "extra NL", "entities": []}, {"text": "What is the name of the high schooler who has the greatest number of friends ?", "entities": []}, {"text": "TruthSELECT T2.name FROM Friend asT1JOIN Highschooler asT2GROUP BY T1.student idORDER BYcount ( * ) DESC LIMIT 1 OursSELECT", "entities": []}, {"text": "T1.name", "entities": []}, {"text": "FROM Highschooler asT1JOIN Friend asT2GROUP BY T2.student idORDER BYcount ( * ) DESC LIMIT 1 Syntax SELECT name FROM Highschooler ORDER", "entities": []}, {"text": "BY grade DESC LIMIT 1 SQLNetSELECT", "entities": []}, {"text": "T1.name", "entities": []}, {"text": "FROM Friend asT1JOIN Friend asT2GROUP BY T2.student idORDER BY *", "entities": []}, {"text": "DESC LIMIT 1 Table 3 : Sample SQL predictions by our model and previous state - of - the - art models on the dev split .", "entities": []}, {"text": "NLdenotes the natural language question and Truth denotes the corresponding ground truth SQL query .", "entities": []}, {"text": "Ours , Syntax , and SQLNet denotes the SQL predictions from our model , SyntaxSQLNet ( Yu et al . , 2018b ) , and modi\ufb01ed SQLNet ( Xu et", "entities": []}, {"text": "al . , 2017 ) by Yu et al . ( 2018c ) , respectively .", "entities": []}]