[{"text": "Proceedings of the 6th Joint Conference on Lexical and Computational Semantics ( * SEM 2017 ) , pages 199\u2013208 , Vancouver , Canada , August 3 - 4 , 2017 .", "entities": []}, {"text": "c", "entities": []}, {"text": "2017 Association for Computational Linguistics Parsing Graphs with Regular Graph Grammars Sorcha Gilroy University of Edinburgh s.gilroy@sms.ed.ac.ukAdam Lopez University of Edinburgh alopez@inf.ed.ac.ukSebastian Maneth Universit \u00a8at Bremen smaneth@uni-bremen.de Abstract Recently , several datasets have become available which represent natural language phenomena as graphs .", "entities": []}, {"text": "Hyperedge Replacement Languages ( HRL ) have been the focus of much attention as a formalism to represent the graphs in these datasets .", "entities": []}, {"text": "Chiang et al .", "entities": []}, {"text": "( 2013 ) prove that HRL graphs can be parsed in polynomial time with respect to the size of the input graph .", "entities": []}, {"text": "We believe that HRL are more expressive than is necessary to represent semantic graphs and we propose the use of Regular Graph Languages ( RGL ; Courcelle 1991 ) , which is a subfamily of HRL , as a possible alternative .", "entities": []}, {"text": "We provide a topdown parsing algorithm for RGL that runs in time linear in the size of the input graph .", "entities": []}, {"text": "1 Introduction NLP systems for machine translation , summarization , paraphrasing , and other tasks often fail to preserve the compositional semantics of sentences and documents because they model language as bags of words , or at best syntactic trees .", "entities": [[5, 7, "TaskName", "machine translation"], [8, 9, "TaskName", "summarization"]]}, {"text": "To preserve semantics , they must model semantics .", "entities": []}, {"text": "In pursuit of this goal , several datasets have been produced which pair natural language with compositional semantic representations in the form of directed acyclic graphs ( DAGs ) , including the Abstract Meaning Representation Bank ( AMR ; Banarescu et al . 2013 ) , the Prague Czech - English Dependency Treebank ( Haji \u02c7c et al . , 2012 ) , Deepbank ( Flickinger et al . , 2012 ) , and the Universal Conceptual Cognitive Annotation ( Abend and Rappoport , 2013 ) .", "entities": []}, {"text": "To make use of this data , we require models of graphs .", "entities": []}, {"text": "Consider how we might use compositional semantic representations in machine translationAnna fehlt ihrem KaterAnna \u2019s cat misses hermiss arg0 arg1", "entities": []}, {"text": "cat poss Anna Figure 1 : Semantic machine translation using AMR ( Jones et al . , 2012 ) .", "entities": [[7, 9, "TaskName", "machine translation"]]}, {"text": "The edge labels identify \u2018 cat \u2019 as the object of the verb \u2018 miss \u2019 , \u2018 Anna \u2019 as the subject of \u2018 miss \u2019 and \u2018 Anna \u2019 as the possessor of \u2018 cat \u2019 .", "entities": []}, {"text": "Edges whose head nodes are not attached to any other edge are interpreted as node labels .", "entities": []}, {"text": "( Figure 1 ) , a two - step process in which semantic analysis is followed by generation .", "entities": []}, {"text": "Jones et al .", "entities": []}, {"text": "( 2012 ) observe that this decomposition can be modeled with a pair of synchronous grammars , each de\ufb01ning a relation between strings and graphs .", "entities": []}, {"text": "Necessarily , one projection of this synchronous grammar produces strings , while the other produces graphs , i.e. , is a graph grammar .", "entities": []}, {"text": "A consequence of this representation is that the complete translation process can be realized by parsing : to analyze a sentence , we parse the input string with the string - generating projection of the synchronous grammar , and read off the synchronous graph from the resulting parse .", "entities": []}, {"text": "To generate a sentence , we parse the graph , and read off the synchronous string from the resulting parse .", "entities": []}, {"text": "In this paper , we focus on the latter problem : using graph grammars to parse input graphs .", "entities": []}, {"text": "We call this graph recognition to avoid confusion with other parsing problems .", "entities": []}, {"text": "Recent work in NLP has focused primarily onhyperedge replacement grammar ( HRG ; Drewes et al . 1997 ) , a context - free graph grammar formalism that has been studied in an NLP context by several researchers ( Chiang et al . , 2013 ; Peng et al . , 2015 ; Bauer and Rambow , 2016 ) .", "entities": []}, {"text": "In particular , Chiang et al . ( 2013 ) propose that HRG could be used to represent semantic graphs , and precisely characterize the complexity of a CKY - style199", "entities": []}, {"text": "algorithm for graph recognition from Lautemann ( 1990 ) to be polynomial in the size of the input graph .", "entities": []}, {"text": "HRGs are very expressive \u2014 they can generate graphs that simulate non - context - free string languages ( Engelfriet and Heyker , 1991 ; Bauer and Rambow , 2016 ) .", "entities": []}, {"text": "This means they are likely more expressive than we need to represent the linguistic phenomena that appear in existing semantic datasets .", "entities": []}, {"text": "In this paper , we propose the use of Regular Graph Grammars ( RGG ; Courcelle 1991 ) a subfamily of HRG that , like its regular counterparts among string and tree languages , is less expressive than context - free grammars but may admit more practical algorithms .", "entities": []}, {"text": "By analogy to Chiang \u2019s CKY - style algorithm for HRG .", "entities": []}, {"text": "We develop an Earley - style recognition algorithm for RGLs that is linear in the size of the input graph .", "entities": []}, {"text": "2 Regular Graph Languages We use the following notation .", "entities": []}, {"text": "If nis an integer , [ n]denotes the set{1, ... ,n } .", "entities": []}, {"text": "Let \u0393be an alphabet , i.e. , a \ufb01nite set .", "entities": []}, {"text": "Then s\u2208\u0393\u2217denotes that s is a sequence of arbitrary length , each element of which is in \u0393. We denote by|s|the length of s. A ranked alphabet is an alphabet \u0393paired with an arity mapping ( i.e. , a total function ) rank : \u0393\u2192N. De\ufb01nition 1 . Ahypergraph ( or simply graph ) over a ranked alphabet", "entities": []}, {"text": "\u0393is a tuple G= ( VG , EG , attG , labG , extG)whereVGis a \ufb01nite set of nodes;EGis a \ufb01nite set of edges ( distinct from VG ) ; att G : EG\u2192V\u2217 Gmaps each edge to a sequence of nodes ; lab G : EG\u2192\u0393maps each edge to a label such that |attG(e)|=rank(lab G(e ) ) ; and ext Gis an ordered subset of VGcalled the external nodes ofG.", "entities": []}, {"text": "We assume that the elements of ext Gare pairwise distinct , and the elements of att G(e)for each edgeeare also pairwise distinct .", "entities": []}, {"text": "An edge eis attached to its nodes by tentacles , each labeled by an integer indicating the node \u2019s position in attG(e ) = ( v1, ... ,v k ) .", "entities": []}, {"text": "The tentacle from eto viwill have label i , so the tentacle labels lie in the set[k]wherek = rank(e ) .", "entities": []}, {"text": "To express that a node vis attached to the ith tentacle of an edge e , we say vert ( e , i )", "entities": []}, {"text": "= v. Likewise , the nodes in ext G are labeled by their position in ext G.", "entities": []}, {"text": "We refer to theith external node of Gby ext G(i)and in \ufb01gures this will be labeled ( i ) .", "entities": []}, {"text": "The rank of an edge eiskif att(e ) = ( v1, ... ,v k)(or equivalently , rank(lab ( e ) ) = k ) .", "entities": []}, {"text": "The rank of a hypergraph G , denoted by rank ( G ) is the size of ext G.Example 1 .", "entities": []}, {"text": "Hypergraph Gin Figure 2 has four nodes ( shown as black dots ) and three hyperedges labeleda , b , andX(shown boxed ) .", "entities": []}, {"text": "The bracketed numbers ( 1)and(2)denote its external nodes and the numbers between edges and the nodes are tentacle labels .", "entities": []}, {"text": "Call the top node v1and , proceeding clockwise , call the other nodes v2,v3 , andv4 .", "entities": []}, {"text": "Call its edges e1,e2ande3 .", "entities": []}, {"text": "Its de\ufb01nition would state att G(e1 )", "entities": []}, {"text": "= ( v1,v2 ) , attG(e2 ) = ( v2,v3 ) , attG(e3 ) = ( v1,v4,v3 ) , labG(e1 ) = a , labG(e2 ) = b , labG(e3 )", "entities": []}, {"text": "= X , and ext G= ( v4,v2 ) .", "entities": []}, {"text": "De\ufb01nition 2 . LetGbe a hypergraph containing an edgeewith att G(e )", "entities": []}, {"text": "= ( v1, ... ,v k)and letH be a hypergraph of rank kwith node and edge sets disjoint from those of G. The replacement ofeby His the graph G / prime = G[e / H ] .", "entities": []}, {"text": "Its node set VG / primeis V\u222aVHwhereV = VG\u2212{v1, ... ,v k } .", "entities": []}, {"text": "Its edge set isEG / prime= ( EG\u2212{e})\u222aEH .", "entities": []}, {"text": "We de\ufb01ne att G /", "entities": []}, {"text": "prime=", "entities": []}, {"text": "att\u222aattHwhere for every e / prime\u2208(EG\u2212{e } ) , att(e ) is obtained from att G(e / prime)by replacing viby theith external node of H. Let lab G / prime = lab\u222alabHwhere lab is the restriction of lab Gto edges inEG\u2212{e } .", "entities": []}, {"text": "Finally , let ext G / prime = extG. Example 2 .", "entities": []}, {"text": "A replacement is shown in Figure 2 . 2.1 Hyperedge Replacement Grammars De\ufb01nition 3 .", "entities": []}, {"text": "Ahyperedge replacement grammar G= ( NG , TG , PG , SG)consists of ranked ( disjoint ) alphabets NGandTGof nonterminal and terminal symbols , respectively , a \ufb01nite set PGof productions , and a start symbol SG\u2208NG .", "entities": []}, {"text": "Every production in PGis of the form X\u2192Gwhere Gis a hypergraph over NG\u222aTGand rank ( G ) = rank(X ) .", "entities": []}, {"text": "For each production p : X\u2192G , we useL(p ) to refer toX(the left - hand side of p ) andR(p ) to refer toG(the right - hand side of p ) .", "entities": []}, {"text": "An edge is a terminal edge if its label is terminal and a nonterminal edge if its label is nonterminal .", "entities": []}, {"text": "A graph is a terminal graph if all of its edges are terminal .", "entities": []}, {"text": "The terminal subgraph of a graph is the subgraph consisting of all terminal edges and their incident nodes .", "entities": []}, {"text": "Given a HRGG , we say that graph Gimmediately derives graphG / prime , denotedG\u2192G / prime , iff there is an edge e\u2208EGand a nonterminal X\u2208NGsuch that lab G(e )", "entities": []}, {"text": "= XandG / prime= G[e / H ] , whereX\u2192His inPG .", "entities": []}, {"text": "We extend the idea of immediate derivation to its transitive closureG\u2192\u2217G / prime , and say here that Gderives G / prime .", "entities": []}, {"text": "For every X\u2208NGwe also use Xto de-200", "entities": []}, {"text": "Xa b(1 ) ( 2 ) G(2)c(1 ) a ( 3)d H(1)c da", "entities": []}, {"text": "( 2 ) ba G[e / H]211 2 1 2321 1 21 221 1 21 21 2 1 2 Figure 2 : The replacement of the X - labeled edge einGby the graphH. Sp : X ( 1)1go1 2 Iarg0Y Z s : ( 1 ) ( 2)1 21 arg0arg1 Xq : W Y ( 2)(1)1 21 1 2arg1 arg0Wt:(1 ) 1 want Yr : Z X ( 2)(1)1 21 1 2arg1 arg0Zu:(1 ) 1 need Table 1 : Productions of a HRG .", "entities": []}, {"text": "The labels p , q , r , s , t , andu label the productions so that we can refer to them in the text .", "entities": []}, {"text": "Note thatYcan rewrite in two ways , either via production r ors .", "entities": []}, {"text": "note the graph consisting of a single edge ewith lab(e )", "entities": []}, {"text": "= Xand nodes ( v1, ... ,v rank(X))such that att G(e )", "entities": []}, {"text": "=", "entities": []}, {"text": "( v1, ... ,v rank(X ) ) , and we de\ufb01ne the language LX(G)as{G|X\u2192\u2217G\u2227Gis terminal } .", "entities": []}, {"text": "The language ofGisL(G )", "entities": []}, {"text": "= LSG(G ) .", "entities": []}, {"text": "We call the family of languages that can be produced by any HRG the hyperedge replacement languages ( HRL ) .", "entities": []}, {"text": "We assume that terminal edges are always of rank 2 , and depict them as directed edges where the direction is determined by the tentacle labels : the tentacle labeled 1 attaches to the source of the edge and the tentacle labeled 2 attaches to the target of the edge .", "entities": []}, {"text": "Example 3 .", "entities": []}, {"text": "Table 1 shows a HRG deriving AMR graphs for sentences of the form \u2018 I need to want to need to want to ... to want to go \u2019 .", "entities": []}, {"text": "Figure 3 is a graph derived by the grammar .", "entities": []}, {"text": "The grammar is somewhat unnatural , a point we will return to ( \u00a7 4 ) .", "entities": []}, {"text": "We can use HRGs to generate chain graphs(1)arg1 arg1 arg1 arg1need want need want go", "entities": []}, {"text": "Iarg0arg0 arg0arg0arg0", "entities": []}, {"text": "Figure 3 : Graph derived by grammar in Table 1 . S ( 1)S ( 2 ) ( 1 ) ( 2)1 2a 1 2b ab Figure 4 : A HRG producing the string language anbn .", "entities": []}, {"text": "( strings ) by restricting the form of the productions in the grammars .", "entities": []}, {"text": "Figure 4 shows a HRG that produces the context - free string languageanbn .", "entities": []}, {"text": "HRGs can simulate the class of mildly context - sensitive languages that is characterized , e.g. , by linear context - free rewriting systems ( LCFRS;Vijay - Shanker et al . 1987 ) , where the fan - out of the LCFRS will in\ufb02uence the maximum rank of nonterminal required in the HRG , see ( Engelfriet and Heyker , 1991 ) .", "entities": []}, {"text": "2.2 Regular Graph Grammars A regular graph grammar ( RGG ; Courcelle 1991 ) is a restricted form of HRG .", "entities": []}, {"text": "To explain the restrictions , we \ufb01rst require some de\ufb01nitions .", "entities": []}, {"text": "De\ufb01nition 4 .", "entities": []}, {"text": "Given a graph G , apath inGfrom a nodevto a nodev / primeis a sequence ( v0,i1,e1,j1,v1)(v1,i2,e2,j2,v2 ) ... ( vk\u22121,ik , ek , jk , vk)(1 ) such thatv0 = v , vk = v / prime , and for each r\u2208[k ] , vert(er , ir ) = vr\u22121andvert(er , jr ) = vr .", "entities": []}, {"text": "The length of this path is k.", "entities": []}, {"text": "A path is terminal if every edge in the path has a terminal label .", "entities": []}, {"text": "A path is internal if eachviis internal for 1\u2264i\u2264k\u22121 .", "entities": []}, {"text": "Note that the endpoints v0andvkof an internal path can be external .", "entities": []}, {"text": "De\ufb01nition 5 .", "entities": []}, {"text": "A HRGGis a Regular Graph Grammar ( or simply RGG ) if each nonterminal inNGhas rank at least one and for each p\u2208PG the following hold:201", "entities": []}, {"text": "( C1)R(p)has at least one edge .", "entities": []}, {"text": "Either it is a single terminal edge , all nodes of which are external , or each of its edges has at least one internal node .", "entities": []}, {"text": "( C2 ) Every pair of nodes in R(p)is connected by a terminal and internal path .", "entities": []}, {"text": "Example 4 .", "entities": []}, {"text": "The grammar in Table 1 is an RGG .", "entities": []}, {"text": "Although HRGs can produce context - free languages ( and beyond ) as shown in Figure 4 , the only string languages RGGs can produce are the regular string languages .", "entities": []}, {"text": "See Figure 5 for an example of a string generating RGG .", "entities": []}, {"text": "Similarly , RGGs can produce regular tree languages , but not context - free tree languages .", "entities": []}, {"text": "Figure 6 shows a tree generating RGG that generates binary trees the internal nodes of which are represented by a - labeled edges , and the leaves of which are represented by b - labeled edges .", "entities": []}, {"text": "Note that these two results of regularity of the string- and tree - languages generated by RGG follow from the fact that graph languages produced by RGG are MSO - de\ufb01nable ( Courcelle , 1991 ) , and the well - known facts that the regular string and graph languages are MSO - de\ufb01nable .", "entities": []}, {"text": "X ( 1)aY ( 1)b 1 1 Figure 5 : A RGG for a regular string language .", "entities": []}, {"text": "X(1 ) YZ(1)1a 1 2 1 1b Figure 6 : A RGG for a regular tree language .", "entities": []}, {"text": "We call the family of languages generated by RGGs the regular graph languages ( RGLs ) .", "entities": []}, {"text": "3 RGL Recognition To recognize RGG , we exploit the property that every nonterminal including the start symbol has rank at least one ( De\ufb01nition 5 ) , and we assume that the corresponding external node is identi\ufb01ed in the input graph .", "entities": []}, {"text": "This mild assumption may be reasonable for applications like AMR parsing , where grammars could be designed so that the external node is always the unique root .", "entities": [[9, 11, "TaskName", "AMR parsing"]]}, {"text": "Later we relax this assumption .", "entities": []}, {"text": "The availability of an identi\ufb01able external node suggests a top - down algorithm , and we take in - spiration from a top - down recognition algorithm for the predictive top - down parsable grammars , another subclass of HRG ( Drewes et al . , 2015 ) .", "entities": []}, {"text": "These grammars , the graph equivalent of LL(1 ) string grammars , are incomparable to RGG , but the algorithms are related in their use of top - down prediction and in that they both \ufb01x an order of the edges in the right - hand side of each production .", "entities": []}, {"text": "3.1 Top - Down Recognition for RGLs Just as the algorithm of Chiang et al .", "entities": []}, {"text": "( 2013 ) generalizes CKY to HRG , our algorithm generalizes Earley \u2019s algorithm ( Earley , 1970 ) .", "entities": []}, {"text": "Both algorithms operate by recognizing incrementally larger subgraphs of the input graph , using a succinct representation for subgraphs that depends on an arbitrarily chosen marker node mof the input graph .", "entities": []}, {"text": "De\ufb01nition 6 .", "entities": []}, {"text": "( Chiang et al . 2013 ; De\ufb01nition 6 ) LetIbe a subgraph of a graph G. Aboundary node ofIis a node which is either an endpoint of an edge in G\\Ior an external node of G. A boundary edge ofIis an edge in Iwhich has a boundary node as an endpoint .", "entities": []}, {"text": "The boundary representation ofIis the tuple b(I )", "entities": []}, {"text": "= /angbracketleftbn(I ) , be(I),m\u2208I / angbracketrightwhere", "entities": []}, {"text": "1 .", "entities": []}, {"text": "bn ( I)is the set of boundary nodes of I 2 . be ( I)is the set of boundary edges of I 3.(m\u2208I)is a \ufb02ag indicating whether the marker node is in I. Chiang et al .", "entities": []}, {"text": "( 2013 ) prove each subgraph has a unique boundary representation , and give algorithms that use only boundary representations to compute the union of two subgraphs , requiring time linear in the number of boundary nodes ; and to check disjointness of subgraphs , requiring time linear in the number of boundary edges .", "entities": []}, {"text": "For each production pof the grammar , we impose a \ufb01xed order on the edges of R(p ) , as in Drewes", "entities": []}, {"text": "et al . ( 2015 ) .", "entities": []}, {"text": "We discuss this order in detail in\u00a73.2 .", "entities": []}, {"text": "As in Earley \u2019s algorithm , we use dotted rules to represent partial recognition of productions : X\u2192\u00afe1 ... \u00afei\u22121\u00b7\u00afei ... \u00afenmeans that we have identi\ufb01ed the edges \u00afe1to\u00afei\u22121and that we must next recognize edge \u00afei .", "entities": []}, {"text": "We write \u00afeand \u00afvfor edges and nodes in productions and eandv for edges and nodes in a derived graph .", "entities": []}, {"text": "When the identity of the sequence is immaterial we abbreviate it as\u03b1 , for example writing X\u2192\u00b7\u03b1 .", "entities": []}, {"text": "We present our recognizer as a deductive proof system ( Shieber et al . , 1995 ) .", "entities": []}, {"text": "The items of the202", "entities": []}, {"text": "Name Rule Conditions PREDICT[b(I),p : X\u2192\u00afe1 ... \u00b7\u00afei ... \u00afen , \u03c6p][q : Y\u2192\u03b1 ]", "entities": []}, {"text": "[ \u03c6p(\u00afei),q : Y\u2192\u00b7\u03b1 , \u03c60q[extR(q)=\u03c6p(\u00afei)]]lab(\u00afei ) = Y SCAN[b(I),X\u2192\u00afe1 ... \u00b7\u00afei ... \u00afen , \u03c6p][e = edglab(\u00afei)(v1, ... ,v m ) ]", "entities": []}, {"text": "[ b(I\u222a{e}),X\u2192\u00afe1 ... \u00b7\u00afei+1 ... \u00afen , \u03c6p[att(\u00afei ) = ( v1, ... ,v m)]]\u03c6p(\u00afei)(j)\u2208VG\u21d2 \u03c6p(\u00afei)(j ) = vert(e , j ) COMPLETE[b(I),p : X\u2192\u00afe1 ... \u00b7\u00afei ... \u00afen , \u03c6p][b(J),q : Y\u2192\u03b1\u00b7,\u03c6q ]", "entities": []}, {"text": "[ b(I\u222aJ),X\u2192\u00afe1 ... \u00b7\u00afei+1 ... \u00afen , \u03c6p[att(\u00afei )", "entities": []}, {"text": "= \u03c6p(extR(q))]]\u03c6p(\u00afei)(j)\u2208VG\u21d2 \u03c6p(\u00afei)(j ) = \u03c6q(extR(q))(j ) , lab(\u00afei )", "entities": []}, {"text": "= Y , EI\u2229EJ=\u2205 Table 2 : The inference rules for the top - down recognizer .", "entities": []}, {"text": "recognizer are of the form", "entities": []}, {"text": "[ b(I),p : X\u2192\u00afe1 ... \u00b7\u00afei ... \u00afen , \u03c6p ] whereIis a subgraph that has been recognized as matching \u00afe1 , ... , \u00afei\u22121;p : X\u2192\u00afe1 , ... , \u00afenis a production in the grammar with the edges in order ; and\u03c6p : ER(p)\u2192V\u2217 Gmaps the endpoints of edges inR(p)to nodes inG.", "entities": []}, {"text": "For each production p , we number the nodes in some arbitrary but \ufb01xed order .", "entities": []}, {"text": "Using this , we construct the function \u03c60 p : ER(p)\u2192V\u2217 R(p)such that for \u00afe\u2208ER(p)if att ( \u00afe ) = ( \u00afv1,\u00afv2)then \u03c60 p(\u00afe )", "entities": []}, {"text": "= ( \u00afv1,\u00afv2 ) .", "entities": []}, {"text": "As we match edges in the graph with edges in p , we assign the nodes \u00afvto nodes in the graph .", "entities": []}, {"text": "For example , if we have an edge \u00afein a production psuch that att ( \u00afe ) = ( \u00afv1,\u00afv2)and we \ufb01nd an edge ewhich matches \u00afe , then we update \u03c6pto record this fact , written \u03c6p[att(\u00afe )", "entities": []}, {"text": "= att(e ) ] .", "entities": []}, {"text": "We also use \u03c6pto record assignments of external nodes .", "entities": []}, {"text": "If we assign the ith external node to v , we write\u03c6p[extp(i )", "entities": []}, {"text": "= v ] .", "entities": []}, {"text": "We write\u03c60 pto represent a mapping with no grounded nodes .", "entities": []}, {"text": "Since our algorithm makes top - down predictions based on known external nodes , our boundary representation must cover the case where a subgraph is empty except for these nodes .", "entities": []}, {"text": "If at some point we know that our subgraph has external nodes \u03c6(\u00afe ) , then we use the shorthand \u03c6(\u00afe)rather than the full boundary representation /angbracketleft\u03c6(\u00afe),\u2205,m\u2208\u03c6(\u00afe)/angbracketright .", "entities": []}, {"text": "To keep notation uniform , we use dummy nonterminalS\u2217/negationslash\u2208NGthat derivesSGvia the productionp0 .", "entities": []}, {"text": "For graphG , our system includes the axiom : [ extG , p0 : S\u2217\u2192\u00b7SG , \u03c60 p0[extR(p0)=extG]].Ourgoal is to prove :", "entities": []}, {"text": "[ b(G),pS : S\u2217\u2192SG\u00b7,\u03c6pS ] where\u03c6pShas a single edge \u00afein its domain which has labelSGinR(pS)and\u03c6pS(\u00afe )", "entities": []}, {"text": "= extG. As in Earley \u2019s algorithm , we have three inference rules : PREDICT , SCAN and COMPLETE ( Table 2 ) .", "entities": [[16, 17, "DatasetName", "SCAN"]]}, {"text": "P REDICT is applied when the edge after the dot is nonterminal , assigning any external nodes that have been identi\ufb01ed .", "entities": []}, {"text": "S CAN is applied when the edge after the dot is terminal .", "entities": []}, {"text": "Using \u03c6p , we may already know where some of the endpoints of the edge should be , so it requires the endpoints of the scanned edge to match .", "entities": []}, {"text": "C OMPLETE requires that each of the nodes of \u00afeiinR(p)have been identi\ufb01ed , these nodes match up with the corresponding external nodes of the subgraph J , and that the subgraphs IandJare edge - disjoint .", "entities": []}, {"text": "We provide a high - level proof that the recognizer is sound and complete .", "entities": []}, {"text": "Proposition 1 . LetGbe a HRG and Ga graph .", "entities": []}, {"text": "Then the goal [ b(G),pS : S\u2217\u2192SG\u00b7,\u03c6pS]can be proved from the axiom", "entities": []}, {"text": "[ extG , pS : S\u2217\u2192\u00b7SG , \u03c6pS[extR(pS)=extG]]if and only if G\u2208 L(G ) .", "entities": []}, {"text": "Proof .", "entities": []}, {"text": "We prove that for each X\u2208NG , [ b(G),pX : X\u2217\u2192X\u00b7,\u03c6pX]can be proved from [ extG , pX : X\u2217\u2192\u00b7X , \u03c6 pX[extR(pX)=extG]]if and only ifG\u2208LX(G)where the dummy nonterminalX\u2217was added to the set of nonterminals andpX : X\u2217\u2192Xwas added to the set of productions .", "entities": []}, {"text": "We prove this by induction on the number of edges inG. We assume that each production in the grammar contains at least one terminal edge .", "entities": []}, {"text": "If the HRG is not in this form , it can be converted into this form203", "entities": []}, {"text": "and in the case of RGGs they are already in this form by de\ufb01nition .", "entities": []}, {"text": "Base Case : LetGconsist of a single edge .", "entities": []}, {"text": "If : AssumeG\u2208LX(G ) .", "entities": []}, {"text": "SinceGconsists of one edge , there must be a production q : X\u2192G.", "entities": []}, {"text": "Apply PREDICT to the axiom and pX : X\u2217\u2192Xto obtain the item [ \u03c6pX(X),q : X\u2192\u00b7G , \u03c60 q[extG = \u03c6pX(X ) ] ] .", "entities": []}, {"text": "Apply SCAN to the single terminal edge that makes up Gto obtain[b(G),q : X\u2192G\u00b7,\u03c6q]and \ufb01nally apply COMPLETE to this and the axiom reach the goal [ b(G),pX : X\u2217\u2192X , \u03c6 pX ] .", "entities": [[1, 2, "DatasetName", "SCAN"]]}, {"text": "Only if : Assume the goal can be reached from the axiom and G = e. Then the item [ b(e),q : X\u2192e , \u03c6q]must have been reached at some point for someq\u2208PG .", "entities": []}, {"text": "Therefore q : X\u2192eis a production and so e = G\u2208LX(G ) .", "entities": []}, {"text": "Assumption : Assume that the proposition holds whenGhas fewer than kedges .", "entities": []}, {"text": "Inductive Step : AssumeGhaskedges .", "entities": []}, {"text": "If : AssumeG\u2208LX(G ) , then there is a productionq : X\u2192HwhereHhas nonterminals Y1, ...", "entities": []}, {"text": ",Y nand there are graphs H1, ... ,H nsuch thatG = H[Y1 / H1] ...", "entities": []}, {"text": "[Yn / Hn ] .", "entities": []}, {"text": "Each graph Hi fori\u2208[n]has fewer than kedges and so we apply the inductive hypothesis to show that we can prove the items [ b(Hi),ri : Yi\u2192Ji , \u03c6ri]for each i\u2208[n ] .", "entities": []}, {"text": "By applying COMPLETE to each such item and applying SCAN to each terminal edge of Hwe reach the goal", "entities": [[9, 10, "DatasetName", "SCAN"]]}, {"text": "[ b(G),pX : X\u2217\u2192X\u00b7,\u03c6pX ] .", "entities": []}, {"text": "Only If : Assume the goal can be proved from the axiom .", "entities": []}, {"text": "Then we must have at some point reached an item of the form [ b(G),q : X\u2192 H , \u03c6 q]and thatHhas nonterminals Y1, ...", "entities": []}, {"text": ",Y n.", "entities": []}, {"text": "This means that there are graphs H1, ... ,H nsuch that[b(Hi),pYi : Y\u2217 i\u2192Yi , \u03c6pYi]for eachi\u2208[n ]", "entities": []}, {"text": "andG = H[Y1 / H1] ...", "entities": []}, {"text": "[Yn / Hn ] .", "entities": []}, {"text": "Since each Hi has fewer than kedges , we apply the inductive hypothesis to get that Hi\u2208LYi(G)for eachi\u2208[n ] and therefore G\u2208LX(G ) .", "entities": []}, {"text": "Example 5 .", "entities": []}, {"text": "Using the RGG in Table 1 , we show how to recognize the graph in Figure 7 , which can be derived by applying production sfollowed by productionu , where the external nodes of Yare ( v3,v2 ) .", "entities": []}, {"text": "Assume the ordering of the edges in productionsis arg1 , arg0 , Z ; the top node is \u00afv1 ; the bottom node is \u00afv2 ; and the node on the right is \u00afv3 ; and that the marker node is not in this subgraph \u2014 we elide reference to it for simplicity .", "entities": []}, {"text": "Let \u00afv4be the top node of R(u)and\u00afv5be the bottom node ofR(u ) .", "entities": []}, {"text": "The external nodes of Yare determinedtop - down , so the recognize of this subgraph is triggered by this item : [ { v3,v2},Y\u2192\u00b7arg1 arg0Z , \u03c60 s[extR(s)= ( v3,v2)]](2 ) where\u03c6s(arg1 )", "entities": []}, {"text": "= ( \u00afv1,v3),\u03c6s(arg0 ) = ( \u00afv1,v2 ) , and\u03c6s(Z ) = ( \u00afv1 ) .", "entities": []}, {"text": "Table 3 shows how we can prove the item", "entities": []}, {"text": "[ /angbracketleft{v3,v2},{e3,e2}/angbracketright , Y\u2192arg1arg0Z\u00b7,\u03c6 ] The boundary representation /angbracketleft{v3,v2},{e3,e2}/angbracketright", "entities": []}, {"text": "in this item represents the whole subgraph shown in Figure 7 .", "entities": []}, {"text": "v1 v4", "entities": []}, {"text": "v2v3 ... ... need ( e1 ) arg0 ( e2)arg1 ( e3 ) Figure 7 : Top left subgraph of Figure 3 .", "entities": []}, {"text": "To refer to nodes and edges in the text , they are labeled v1,v2,v3,e1,e2 , ande3 .", "entities": []}, {"text": "3.2 Normal Ordering Our algorithm requires a \ufb01xed ordering of the edges in the right - hand sides of each production .", "entities": []}, {"text": "We will constrain this ordering to exploit the structure of RGG productions , allowing us to bound recognition complexity .", "entities": []}, {"text": "If s= \u00afe1 ... \u00afenis an order , de\ufb01nesi : j= \u00afei ... \u00afej .", "entities": []}, {"text": "De\ufb01nition 7 . Lets= \u00afe1 , ... , \u00afenbe an edge order of a right - hand side of a production .", "entities": []}, {"text": "Then sis normal if it has the following properties : 1.\u00afe1is connected to an external node , 2.s1 : jis a connected graph for all j\u2208[n ] 3 . if\u00afeiis nonterminal , each endpoint of \u00afeimust be incident with some terminal edge \u00afejfor which j < i .", "entities": []}, {"text": "Example 6 .", "entities": []}, {"text": "The ordering of the edges of productionsin Example 5 is normal .", "entities": []}, {"text": "Arbitrary HRGs do not necessarily admit a normal ordering .", "entities": []}, {"text": "For example , the graph in Figure 8 can not satisfy Properties 2 and 3 simultaneously .", "entities": []}, {"text": "However , RGGs do admit a normal ordering .", "entities": []}, {"text": "( 1 ) X ( 2)a 1 2 b Figure 8 : This graph can not be normally ordered.204", "entities": []}, {"text": "Current Item Reason 1.[{v3,v2},Y\u2192\u00b7arg1arg0Z , \u03c60 s[extR(s)= ( v3,v2 ) ] ]", "entities": []}, {"text": "Equation 2 2.[/angbracketleft{v3,v2,v1},{e3}/angbracketright , Y\u2192arg1\u00b7arg0Z , \u03c6s[att(arg1 )", "entities": []}, {"text": "= ( v1,v3 ) ] ]", "entities": []}, {"text": "SCAN : 1 . ande3 = edgarg1(v1,v3 ) 3.[/angbracketleft{v3,v2,v1},{e3,e2}/angbracketright , Y\u2192arg1arg0\u00b7Z , \u03c6s[att(arg0 )", "entities": [[0, 1, "DatasetName", "SCAN"]]}, {"text": "= ( v1,v2 ) ] ]", "entities": []}, {"text": "SCAN : 2 . ande2 = edgarg0(v1,v2 ) ]", "entities": [[0, 1, "DatasetName", "SCAN"]]}, {"text": "4.[(v1),Z\u2192\u00b7need , \u03c60 u[extR(u)= ( v1 ) ] ] PREDICT : 3 . andZ\u2192need 5.[/angbracketleft{v1,v4},{e1}/angbracketright , Z\u2192need\u00b7,\u03c6u[att(need ) = ( v1,v4 ) ] ] SCAN : 4 . ande1 = edgneed(v1,v4 )", "entities": [[24, 25, "DatasetName", "SCAN"]]}, {"text": "6.[/angbracketleft{v3,v2},{e3,e2}/angbracketright , Y\u2192arg1arg0Z\u00b7,\u03c6s[att(Z )", "entities": []}, {"text": "= ( v1 ) ] ] COMPLETE :", "entities": []}, {"text": "3 . and 5 .", "entities": []}, {"text": "Table 3 : The steps of recognizing that the subgraph shown in Figure 7 is derived from productions r2anduin the grammar in Table 1 .", "entities": []}, {"text": "Proposition 2 .", "entities": []}, {"text": "IfGis an RGG , for every p\u2208PG , there is a normal ordering of the edges in R(p ) .", "entities": []}, {"text": "Proof .", "entities": []}, {"text": "IfR(p)contains a single node then it must be an external node and it must have a terminal edge attached to it since R(p)must contain at least one terminal edge .", "entities": []}, {"text": "If R(p)contains multiple nodes then by C2 there must be terminal internal paths between all of them , so there must be a terminal edge attached to the external node , which we use to satisfy Property 1 .", "entities": []}, {"text": "To produce a normal ordering , we next select terminal edges once one of their endpoints is connected to an ordered edge , and nonterminal edges once all endpoints are connected to ordered edges , possible by C2 .", "entities": []}, {"text": "Therefore , Properties 2 and 3 are satis\ufb01ed .", "entities": []}, {"text": "A normal ordering tightly constrains the recognition of edges .", "entities": []}, {"text": "Property 3 ensures that when we apply P REDICT , the external nodes of the predicted edge are all bound to speci\ufb01c nodes in the graph .", "entities": []}, {"text": "Properties 1 and 2 ensure that when we apply S CAN , at least one endpoint of the edge is bound ( \ufb01xed ) .", "entities": []}, {"text": "3.3 Recognition Complexity Assume a normally - ordered RGG .", "entities": []}, {"text": "Let the maximum number of edges in the right - hand side of any production be m ; the maximum number of nodes in any right - hand side of a production k ; the maximum degree of any node in the input graph d ; and the number of nodes in the input graph n.", "entities": []}, {"text": "As previously mentioned , Drewes et al .", "entities": []}, {"text": "( 2015 ) also propose a HRG recognizer which can recognize a subclass of HRG ( incomparable to RGG ) called the predictive top - down parsable grammars .", "entities": []}, {"text": "Their recognizer in this case runs in O(n2)time .", "entities": []}, {"text": "A well - known bottom - up recognizing algorithm for HRG was \ufb01rst proposed by Lautemann ( 1990).In this paper , the recognizer is shown to be polynomial in the size of the input graph .", "entities": []}, {"text": "Later , Chiang et al .", "entities": []}, {"text": "( 2013 ) formulate the same algorithm more precisely and show that the recognizing complexity isO((3d\u00d7n)k+1)wherekin their case is the treewidth of the grammar .", "entities": []}, {"text": "Remark 1 .", "entities": []}, {"text": "The maximum number of nodes in any right - hand side of a production ( k ) is also the maximum number of boundary nodes for any subgraph in the recognizer .", "entities": []}, {"text": "COMPLETE combines subgraphs IandJonly when the entire subgraph derived from Yhas been recognized .", "entities": []}, {"text": "Boundary nodes of Jare also boundary nodes of Ibecause they are nodes in the terminal subgraph of R(p)whereYconnects .", "entities": []}, {"text": "The boundary nodes of I\u222aJare also bounded by k since form a subset of the boundary nodes of I. Remark 2 .", "entities": []}, {"text": "Given a boundary node , there are at most ( dm)k\u22121ways of identifying the remaining boundary nodes of a subgraph that is isomorphic to the terminal subgraph of the right - hand side of a production .", "entities": []}, {"text": "The terminal subgraph of each production is connected by C2 , with a maximum path length of m. For each edge in the path , there are at most d subsequent edges .", "entities": []}, {"text": "Hence for the k\u22121remaining boundary nodes there are ( dm)k\u22121ways of choosing them .", "entities": []}, {"text": "We count instantiations of C OMPLETE for an upper bound on complexity ( McAllester , 2002 ) , using similar logic to ( Chiang et al . , 2013 ) .", "entities": []}, {"text": "The number of boundary nodes of I , J andI\u222aJis at mostk .", "entities": []}, {"text": "Therefore , if we choose an arbitrary node to be some boundary node of I\u222aJ , there are at most ( dm)k\u22121ways of choosing its remaining boundary nodes .", "entities": []}, {"text": "For each of these nodes , there are at most ( 3d)kstates of their attached boundary edges : inI , inJ , or in neither .", "entities": []}, {"text": "The total number205", "entities": []}, {"text": "of instantiations is O(n(dm)k\u22121(3d)k ) , linear in the number of input nodes and exponential in the degree of the input graph .", "entities": []}, {"text": "Note that in the case of the AMR dataset ( Banarescu et al . 2013 ) , the maximum node degree is 17 and the average is 2.12 .", "entities": []}, {"text": "We observe that RGGs could be relaxed to produce graphs with no external nodes by adding a dummy nonterminal S / primewith rank 0 and a single productionS / prime\u2192S. To adapt the recognition algorithm , we would \ufb01rst need to guess where the graph starts .", "entities": [[23, 24, "DatasetName", "0"]]}, {"text": "This would add a factor of nto the complexity as the graph could start at any node .", "entities": []}, {"text": "4 Discussion and Conclusions We have presented RGG as a formalism that could be useful for semantic representations and we have provided a top - down recognition algorithm for them .", "entities": []}, {"text": "The constraints of RGG enable more ef\ufb01cient recognition than general HRG , and this tradeoff is reasonable since HRG is very expressive \u2014 when generating strings , it can express non - context - free languages ( Engelfriet and Heyker , 1991 ; Bauer and Rambow , 2016 ) , far more power than needed to express semantic graphs .", "entities": []}, {"text": "On the other hand , RGG is so constrained that it may not be expressive enough : it would be more natural to derive the graph in Figure 4 from outermost to innermost predicate ; but constraint C2 makes it dif\ufb01cult to express this , and the grammar in Table 1 does not .", "entities": []}, {"text": "Perhaps we need less expressivity than HRG but more than RGG .", "entities": []}, {"text": "HRL MSOL Graphs CFTL CFL\u2217RTL", "entities": []}, {"text": "Trees RL StringsRGLDAGAL Figure 9 : A Hasse diagram of various string , tree and graph language families .", "entities": []}, {"text": "An arrow from family A to family B indicates that family A is a subfamily of family B. A possible alternative would be to consider Restricted DAG Grammars ( RDG ; Bj \u00a8orklund et al . 2016 ) .", "entities": [[25, 26, "DatasetName", "Restricted"]]}, {"text": "Parsing for a \ufb01xed such grammar can be achieved in quadratic time with respect to the input graph .", "entities": []}, {"text": "It is known that for a \ufb01xed HRG generatingk - connected hypergraphs consisting of hyperedges of rank konly , parsing can be carried out in cubic time ( k - HRG ; ( Drewes , 1993)).More general than RDGs a is the class of graph languages recognized by DAG automata ( DAGAL ; Blum and Drewes 2016 ) , for which the deterministic variant provides polynomial time parsing .", "entities": []}, {"text": "Note that RGGs can generate graph languages of unbounded node degree .", "entities": []}, {"text": "With respect to expressive power , RDGs and k - HRGs are incomparable to RGGs .", "entities": []}, {"text": "Figure 9 shows the relationships between the context - free and regular languages for strings , trees and graphs .", "entities": []}, {"text": "Monadic - second order logic ( MSOL ; Courcelle and Engelfriet 2011 ) is a form of logic which when restricted to strings gives us exactly the regular string languages and when restricted to trees gives us exactly the regular tree languages .", "entities": []}, {"text": "RGLs lie in the intersection of HRG and MSOL on graphs but they do not make up this entire intersection .", "entities": []}, {"text": "Courcelle ( 1991 ) de\ufb01ned ( non - constructively ) this intersection to be the strongly context - free languages ( SCFL ) .", "entities": []}, {"text": "We believe that there may be other formalisms that are subfamilies of SCFL which may be useful for semantic representations .", "entities": []}, {"text": "All inclusions shown in Figure 9 are strict .", "entities": []}, {"text": "For instance , RGL can not produce \u201c star graphs \u201d ( one node that has edges to n other nodes ) , while DAGAL and HRL can produce such graphs .", "entities": []}, {"text": "It is well - known that HRL and MSOL are incomparable .", "entities": []}, {"text": "There is a language in RGL that is not in DAGAL , for instance , \u201c ladders \u201d ( two string graphs of nnodes each , with an edge between the ith node of each string ) .", "entities": []}, {"text": "Another alternative formalism to RGG that is de\ufb01ned as a restriction of HRG are Tree - like Grammars ( TLG ; Matheja et al . 2015 ) .", "entities": []}, {"text": "They de\ufb01ne a subclass of SCFL , i.e. , they are MSO de\ufb01nable .", "entities": []}, {"text": "TLGs have been considered for program veri\ufb01cation , where closure under intersection of the formalism is essential .", "entities": []}, {"text": "Note that RGGs are also closed under intersection .", "entities": []}, {"text": "While TLG and RDG are both incomparable to RGG , they share important characteristics , including the fact that the terminal subgraph of every production is connected .", "entities": []}, {"text": "This means that our top - down recognition algorithm is applicable to both .", "entities": []}, {"text": "In the future we would like to investigate larger , less restrictive ( and more linguistically expressive ) subfamilies of SCFL .", "entities": []}, {"text": "We plan to implement and evaluate our algorithm experimentally .", "entities": []}, {"text": "Acknowledgments This work was supported in part by the EPSRC Centre for Doctoral Training in Data Science,206", "entities": []}, {"text": "funded by the UK Engineering and Physical Sciences Research Council ( grant EP / L016427/1 ) and the University of Edinburgh ; and in part by a Google faculty research award ( to AL ) .", "entities": [[27, 28, "DatasetName", "Google"]]}, {"text": "We thank Clara Vania , Sameer Bansal , Ida Szubert , Federico Fancellu , Antonis Anastasopoulos , Marco Damonte , and the anonymous reviews for helpful discussion of this work and comments on previous drafts of the paper .", "entities": []}, {"text": "References Omri Abend and Ari Rappoport .", "entities": []}, {"text": "2013 .", "entities": []}, {"text": "Universal conceptual cognitive annotation ( ucca ) .", "entities": []}, {"text": "In ACL ( 1 ) .", "entities": []}, {"text": "The Association for Computational Linguistics , pages 228\u2013238 .", "entities": []}, {"text": "http://dblp.unitrier.de/db/conf/acl/acl2013-1.html#AbendR13 .", "entities": []}, {"text": "Laura Banarescu , Claire Bonial , Shu Cai , Madalina Georgescu , Kira Grif\ufb01tt , Ulf Hermjakob , Kevin Knight , Philipp Koehn , Martha Palmer , and Nathan Schneider .", "entities": []}, {"text": "2013 .", "entities": []}, {"text": "Abstract meaning representation for sembanking .", "entities": []}, {"text": "In Proceedings of the 7th Linguistic Annotation Workshop and Interoperability with Discourse .", "entities": []}, {"text": "Association for Computational Linguistics , So\ufb01a , Bulgaria , pages 178\u2013186 .", "entities": []}, {"text": "http://www.aclweb.org/anthology/W13-2322 .", "entities": []}, {"text": "Daniel Bauer and Owen Rambow .", "entities": []}, {"text": "2016 .", "entities": []}, {"text": "Hyperedge replacement and nonprojective dependency structures .", "entities": []}, {"text": "In Proceedings of the 12th International Workshop on Tree Adjoining Grammars and Related Formalisms ( TAG+12 ) , June 29 - July 1 , 2016 , Heinrich Heine University , D \u00a8usseldorf , Germany .", "entities": []}, {"text": "pages 103 \u2013 111 .", "entities": []}, {"text": "http://aclweb.org/anthology/W/W16/W163311.pdf .", "entities": []}, {"text": "Henrik", "entities": []}, {"text": "Bj \u00a8orklund , Frank Drewes , and Petter Ericson .", "entities": []}, {"text": "2016 .", "entities": []}, {"text": "Between a Rock and a Hard Place \u2013 Uniform Parsing for Hyperedge Replacement DAG Grammars , Springer International Publishing , Cham , pages 521\u2013532 .", "entities": []}, {"text": "https://doi.org/10.1007/9783-319-30000-9 40 .", "entities": []}, {"text": "Johannes Blum and Frank Drewes . 2016 .", "entities": []}, {"text": "Properties of regular DAG languages .", "entities": []}, {"text": "In Language and Automata Theory and Applications - 10th International Conference , LATA 2016 , Prague , Czech Republic , March 14 - 18 , 2016 , Proceedings .", "entities": []}, {"text": "pages 427\u2013438 .", "entities": []}, {"text": "https://doi.org/10.1007/978-3-319-30000-9 33 .", "entities": []}, {"text": "David Chiang , Jacob Andreas , Daniel Bauer , Karl Moritz Hermann , Bevan Jones , and Kevin Knight .", "entities": []}, {"text": "2013 .", "entities": []}, {"text": "Parsing graphs with hyperedge replacement grammars .", "entities": []}, {"text": "In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics ( Volume 1 : Long Papers ) .", "entities": []}, {"text": "Association for Computational Linguistics , So\ufb01a , Bulgaria , pages 924\u2013932 .", "entities": []}, {"text": "http://www.aclweb.org/anthology/P13-1091.Bruno Courcelle .", "entities": []}, {"text": "1991 .", "entities": []}, {"text": "The monadic second - order logic of graphs V : on closing the gap between de\ufb01nability and recognizability .", "entities": []}, {"text": "Theor .", "entities": []}, {"text": "Comput .", "entities": []}, {"text": "Sci . 80(2):153\u2013202 .", "entities": []}, {"text": "https://doi.org/10.1016/03043975(91)90387-H. Bruno Courcelle and Joost Engelfriet .", "entities": []}, {"text": "2011 .", "entities": []}, {"text": "Graph Structure and Monadic Second - Order Logic , a Language Theoretic Approach .", "entities": []}, {"text": "Cambridge University Press .", "entities": [[0, 1, "DatasetName", "Cambridge"]]}, {"text": "Frank Drewes .", "entities": []}, {"text": "1993 .", "entities": []}, {"text": "Np - completeness of kconnected hyperedge - replacement languages of order k. Inf . Process .", "entities": []}, {"text": "Lett . 45(2):89\u201394 .", "entities": []}, {"text": "https://doi.org/10.1016/0020-0190(93)90221-T. Frank Drewes , Berthold Hoffmann , and Mark Minas .", "entities": []}, {"text": "2015 .", "entities": []}, {"text": "Predictive Top - Down Parsing for Hyperedge Replacement Grammars , Springer International Publishing , Cham , pages 19\u201334 .", "entities": []}, {"text": "https://doi.org/10.1007/978-3-319-21145-9 2 . Frank Drewes , Hans - J \u00a8org Kreowski , and Annegret Habel .", "entities": []}, {"text": "1997 .", "entities": []}, {"text": "Hyperedge replacement graph grammars .", "entities": []}, {"text": "In Grzegorz Rozenberg , editor , Handbook of Graph Grammars and Computing by Graph Transformation , World Scienti\ufb01c , pages 95\u2013162 .", "entities": []}, {"text": "Jay Earley .", "entities": []}, {"text": "1970 .", "entities": []}, {"text": "An ef\ufb01cient context - free parsing algorithm .", "entities": []}, {"text": "ACM , New York , NY , USA , volume 13 , pages 94\u2013102 . https://doi.org/10.1145/362007.362035 .", "entities": [[0, 1, "DatasetName", "ACM"]]}, {"text": "Joost Engelfriet and Linda Heyker . 1991 .", "entities": []}, {"text": "The string generating power of context - free hypergraph grammars .", "entities": []}, {"text": "Journal of Computer and System Sciences 43(2):328\u2013360 .", "entities": []}, {"text": "Dan Flickinger , Yi Zhang , and Valia Kordoni .", "entities": []}, {"text": "2012 .", "entities": []}, {"text": "Deepbank : a dynamically annotated treebank of the Wall Street Journal .", "entities": []}, {"text": "In Proceedings of the Eleventh International Workshop on Treebanks and Linguistic Theories ( TLT11 ) .", "entities": []}, {"text": "Lisbon , pages 85\u201396 .", "entities": []}, {"text": "HU .", "entities": []}, {"text": "Jan Haji \u02c7c , Eva Haji \u02c7cov\u00b4a , Jarmila Panevov , Petr Sgall , Ond \u02c7rej Bojar , Silvie Cinkov \u00b4 a , Eva Fu \u02c7c\u00b4\u0131kov\u00b4a , Marie Mikulov \u00b4 a , Petr Pajas , Jan Popelka ,", "entities": []}, {"text": "Ji \u02c7r\u00b4\u0131 Semeck \u00b4 y , Jana \u02c7Sindlerov \u00b4 a , Jan \u02c7St\u02c7ep\u00b4anek , Josef Toman , Zde\u02c7nka Ure \u02c7sov\u00b4a , and Zden \u02c7ek\u02c7Zabokrtsk \u00b4 y. 2012 .", "entities": []}, {"text": "Announcing prague czech - english dependency treebank 2.0 .", "entities": []}, {"text": "In Nicoletta Calzolari ( Conference Chair ) , Khalid Choukri , Thierry Declerck , Mehmet Uur Doan , Bente Maegaard , Joseph Mariani , Asuncion Moreno , Jan Odijk , and Stelios Piperidis , editors , Proceedings of the Eight International Conference on Language Resources and Evaluation ( LREC\u201912 ) .", "entities": []}, {"text": "European Language Resources Association ( ELRA ) , Istanbul , Turkey .", "entities": []}, {"text": "Bevan Jones , Jacob Andreas , Daniel Bauer , Karl Mortiz Hermann , and Kevin Knight .", "entities": []}, {"text": "2012 .", "entities": []}, {"text": "Semanticsbased machine translation with hyperedge replacement grammars .", "entities": [[1, 3, "TaskName", "machine translation"]]}, {"text": "In Proceedings of COLING .207", "entities": []}, {"text": "Clemens Lautemann .", "entities": []}, {"text": "1990 .", "entities": []}, {"text": "The complexity of graph languages generated by hyperedge replacement .", "entities": []}, {"text": "Acta Informatica 27(5):399\u2013421 .", "entities": []}, {"text": "https://doi.org/10.1007/BF00289017 .", "entities": []}, {"text": "Christoph Matheja , Christina Jansen , and Thomas Noll .", "entities": []}, {"text": "2015 .", "entities": []}, {"text": "Tree - Like Grammars and Separation Logic , Springer International Publishing , Cham , pages 90\u2013108 .", "entities": []}, {"text": "https://doi.org/10.1007/978-3-31926529-2 6 .", "entities": []}, {"text": "David McAllester . 2002 .", "entities": []}, {"text": "On the complexity analysis of static analyses .", "entities": []}, {"text": "J. ACM 49(4):512\u2013537 .", "entities": [[1, 2, "DatasetName", "ACM"]]}, {"text": "https://doi.org/10.1145/581771.581774 .", "entities": []}, {"text": "Xiaochang Peng , Linfeng Song , and Daniel Gildea . 2015 .", "entities": []}, {"text": "A synchronous hyperedge replacement grammar based approach for AMR parsing .", "entities": [[8, 10, "TaskName", "AMR parsing"]]}, {"text": "In Proceedings of the 19th Conference on Computational Natural Language Learning , CoNLL 2015 , Beijing , China , July 30 - 31 , 2015 .", "entities": []}, {"text": "pages 32\u201341 .", "entities": []}, {"text": "http://aclweb.org/anthology/K/K15/K15-1004.pdf .", "entities": []}, {"text": "Stuart M. Shieber , Yves Schabes , and Fernando C. N. Pereira .", "entities": []}, {"text": "1995 .", "entities": []}, {"text": "Principles and implementation of deductive parsing .", "entities": []}, {"text": "Journal of Logic Programming 24(1 - 2 ) .", "entities": []}, {"text": "K. Vijay - Shanker , David J. Weir , and Aravind K. Joshi . 1987 .", "entities": []}, {"text": "Characterizing structural descriptions produced by various grammatical formalisms .", "entities": []}, {"text": "InProceedings of the 25th Annual Meeting on Association for Computational Linguistics .", "entities": []}, {"text": "Association for Computational Linguistics , Stroudsburg , PA , USA , ACL \u2019 87 , pages 104\u2013111 .", "entities": []}, {"text": "https://doi.org/10.3115/981175.981190.208", "entities": []}]