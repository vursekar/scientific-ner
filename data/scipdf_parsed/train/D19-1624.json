{"authors": "Dongjun Lee", "pub_date": "", "title": "Clause-Wise and Recursive Decoding for Complex and Cross-Domain Text-to-SQL Generation", "abstract": "Most deep learning approaches for text-to-SQL generation are limited to the WikiSQL dataset, which only supports very simple queries over a single table. We focus on the Spider dataset, a complex and crossdomain text-to-SQL task, which includes complex queries over multiple tables. In this paper, we propose a SQL clause-wise decoding neural architecture with a self-attention based database schema encoder to address the Spider task. Each of the clause-specific decoders consists of a set of sub-modules, which is defined by the syntax of each clause. Additionally, our model works recursively to support nested queries. When evaluated on the Spider dataset, our approach achieves 4.6% and 9.8% accuracy gain in the test and dev sets, respectively. In addition, we show that our model is significantly more effective at predicting complex and nested queries than previous work.", "sections": [{"heading": "Introduction", "text": "Text-to-SQL generation is the task of translating a natural language question into the corresponding SQL. Recently, various deep learning approaches have been proposed based on the WikiSQL dataset (Zhong et al., 2017). However, because WikiSQL contains only very simple queries over just a single table, these approaches (Xu et al., 2017;Huang et al., 2018;Yu et al., 2018a;Dong and Lapata, 2018) cannot be applied directly to generate complex queries containing elements such as JOIN, GROUP BY, and nested queries.\nTo overcome this limitation, Yu et al. (2018c) introduced Spider, a new complex and crossdomain text-to-SQL dataset.\nIt contains a large number of complex queries over different databases with multiple tables. It also requires a model to generalize to unseen database schema as different databases are used for training and testing. Therefore, a model should understand not only the natural language question but also the schema of the corresponding database to predict the correct SQL query.\nIn this paper, we propose a novel SQL-specific clause-wise decoding neural network model to address the Spider task. We first predict a sketch for each SQL clause (e.g., SELECT, WHERE) with text classification modules. Then, clause-specific decoders find the columns and corresponding operators based on the sketches. Our contributions are summarized as follows.\n\u2022 We decompose the clause-wise SQL decoding process. We also modularize each of the clause-specific decoders into sub-modules based on the syntax of each clause. Our architecture enables the model to learn clausedependent context and also ensures the syntactic correctness of the predicted SQL.\n\u2022 Our model works recursively so that it can predict nested queries.\n\u2022 We also introduce a self-attention based database schema encoder that enables our model to generalize to unseen databases.\nIn the experiment on the Spider dataset, we achieve 24.3% and 28.8% exact SQL matching accuracy on the test and dev set respectively, which outperforms the previous state-of-the-art approach (Yu et al., 2018b) by 4.6% and 9.8%. In addition, we show that our approach is significantly more effective compared to previous work at predicting not only simple SQL queries, but also complex and nested queries.", "n_publication_ref": 7, "n_figure_ref": 0}, {"heading": "Related Work", "text": "Our work is related to the grammar-based constrained decoding approaches for semantic parsing (Yin and Neubig, 2017;Rabinovich et al., 2017;Iyer et al., 2018). While their approaches are focused on general purpose code generation, we instead focus on SQL-specific grammar to address the text-to-SQL task. Our task differs from code generation in two aspects. First, it takes a database schema as an input in addition to natural language. To predict SQL correctly, a model should fully understand the relationship between the question and the schema. Second, as SQL is a non-procedural language, predictions of SQL clauses do not need to be done sequentially.\nFor text-to-SQL generation, several SQLspecific approaches have been proposed (Zhong et al., 2017;Xu et al., 2017;Huang et al., 2018;Yu et al., 2018a;Dong and Lapata, 2018;Yavuz et al., 2018) based on WikiSQL dataset (Zhong et al., 2017). However, all of them are limited to the specific WikiSQL SQL sketch, which only supports very simple queries. It includes only the SELECT and WHERE clauses, only a single expression in the SELECT clause, and works only for a single table. To predict more complex SQL queries, sequence-to-sequence (Iyer et al., 2017;Finegan-Dollak et al., 2018) and template-based (Finegan-Dollak et al., 2018;Lee et al., 2019) approaches have been proposed. However, they focused only on specific databases such as ATIS (Price, 1990) and GeoQuery (Zelle and Mooney, 1996). Because they only considered question and SQL pairs without requiring an understanding of database schema, their approaches cannot generalize to unseen databases. SyntaxSQLNet (Yu et al., 2018b) is the first and state-of-the-art model for the Spider (Yu et al., 2018c), a complex and cross-domain text-to-SQL task. They proposed an SQL specific syntax tree-based decoder with SQL generation history. Our approach differs from their model in the following aspects. First, taking into account that SQL corresponds to non-procedural language, we develop a clause-specific decoder for each SQL clause, where SyntaxSQLNet predicts SQL tokens sequentially. For example, in SyntaxSQL-Net, a single column prediction module works both in the SELECT and WHERE clauses, depending on the SQL decoding history. In contrast, we define and train decoding modules separately for each SQL clause to fully utilize clausedependent context. Second, we apply sequenceto-sequence architecture to predict columns instead of using the sequence-to-set framework from SyntaxSQLNet, because correct ordering is essential for the GROUP BY and ORDER BY clauses. Finally, we introduce a self-attention mechanism (Lin et al., 2017) to efficiently encode database schema, which includes multiple tables.", "n_publication_ref": 19, "n_figure_ref": 0}, {"heading": "Methodology", "text": "We predict complex SQL clause-wisely as described in Figure 1. Each clause is predicted consecutively by at most three different types of modules (sketch, column, operator). The same architecture recursively predicts nested queries with temporal predicted SQL as an additional input.", "n_publication_ref": 0, "n_figure_ref": 1}, {"heading": "Question and Schema Encoding", "text": "We encode a natural language question with a bidirectional LSTM. We denote H Q \u2208 R d\u00d7|X| as the question encoding, where d is the number of LSTM units and |X| is the number of tokens in the question.\nTo encode a database schema, we consider each column in its tables as a concatenated sequence of words from the table name and column name with a separation token. (e.g., [student, [SEP], first, name]). First, we apply bi-directional LSTM over this sequence for each column. Then, we apply the self-attention mechanism (Lin et al., 2017) over the LSTM outputs to form a summarized fixedsize vector for each column. For the ith column, its encoding h\n(i) col \u2208 R d is computed by a weighted sum of the LSTM output o (i) col \u2208 R d\u00d7|L| as follows: \u03b1 = softmax(w T tanh(o (i) col ))(1)\nh (i) col = o (i) col \u03b1 T (2)\nwhere |L| is the number of tokens in the column and w \u2208 R d is a trainable parameter. We denote\nH col = [h (1) col , ...h (|C|)\ncol ] as columns encoding where |C| is the number of columns in the database.", "n_publication_ref": 2, "n_figure_ref": 0}, {"heading": "Sketch Prediction", "text": "We predict the clause-wise sketch via 8 different text classification modules that include the number of SQL expressions in each clause, the presence of LIMIT clause, and the presence of INTERSECT/UNION/EXCEPT as described in Figure 1. All of them share the same model architecture but are trained separately. For the classification, we applied attention-based bi-directional LSTM following Zhou et al. (2016).\nFirst, we compute sentence representation r s \u2208 R d by a weighted sum of question encoding H Q \u2208 R d\u00d7|X| . Then we apply the softmax classifier to choose the sketch as follows:\n\u03b1 s = softmax(w T s tanh(H Q )) (3) r s = H Q \u03b1 T s (4) P sketch = softmax(W s r s + b s ) (5)\nwhere w s \u2208 R d , W s \u2208 R ns\u00d7d , b s \u2208 R ns are trainable parameters and n s is the number of possible sketches.", "n_publication_ref": 1, "n_figure_ref": 1}, {"heading": "Columns and Operators Prediction", "text": "To predict columns and operators, we use the LSTM decoder with the attention mechanism (Luong et al., 2015) such that the number of decoding steps are decided by the sketch prediction module.\nWe train 5 different column prediction modules separately for each SQL clause, but they share the same architecture.\nIn the column prediction module, the hidden state of the decoder at the t-th decoding step is computed as\nd (t) col (\u2208 R d ) = LSTM(d (t\u22121) col , h (t\u22121) col ), where h (t\u22121) col \u2208 R d is\nan encoding of the predicted column in the previous decoding step. The context vector r (t) is computed by a weighted sum of question encodings H Q \u2208 R d\u00d7|X| based on attention weight as follows:\n\u03b1 (t) = softmax(d (t) col T H Q ) (6) r (t) = H Q \u03b1 (t) T (7)\nThen, the attentional output of the t-th decoding step a (t)\ncol is computed as a linear combination of d (t) col \u2208 R d and r (t) \u2208 R d followed by tanh activation.\na (t) col = tanh(W 1 d (t) col + W 2 r (t) )(8)\nwhere W 1 , W 2 \u2208 R d\u00d7d are trainable parameters. Finally, the probability for each column at the tth decoding step is computed as a dot product between a (t)\ncol \u2208 R d and the encoding of each column in H col \u2208 R d\u00d7|C| followed by softmax.\nP (t) col = softmax(a (t) col T H col )(9)\nTo predict corresponding operators for each predicted column, we use a decoder of the same architecture as in the column prediction module. The only difference is that a decoder input at the t-th decoding step is an encoding of the t-th predicted column from the column prediction module.\nd (t) op = LSTM(d (t\u22121) op , h (t) col ) (10\n)\nAttentional output a (t)\nop \u2208 R d is computed identically to Eq. (8). Then, the probability for operators corresponding to the t-th predicted column is computed by the softmax classifier as follows:\nP (t) op = softmax(W o a (t) op + b o )(11)\nwhere W o \u2208 R no\u00d7d and b o \u2208 R no are trainable parameters and n o is the number of possible operators.", "n_publication_ref": 1, "n_figure_ref": 0}, {"heading": "From Clause Prediction", "text": "After the predictions of all the other clauses, we use a heuristic to generate the FROM clause. We first collect all the columns that appear in the predicted SQL, and then we JOIN tables that include these predicted columns.", "n_publication_ref": 0, "n_figure_ref": 0}, {"heading": "Recursion for Nested Queries", "text": "To predict the presence of a sub-query, we train another module that has the same architecture as the operator prediction module. Instead of predicting corresponding operators for each column, it predicts whether each column is compared to a variable (e.g., WHERE age > 3) or to a sub-query (e.g., WHERE age > (SELECT avg(age) ..)   ). This input is encoded in the same way as question encoding described in Section 3.1. Then, the rest of the SQL generation process is identical to that described in Section 3.2-3.4. After the sub-query is predicted, it replaces the [SUB QUERY] token to form the final query.", "n_publication_ref": 0, "n_figure_ref": 0}, {"heading": "Experiments", "text": "", "n_publication_ref": 0, "n_figure_ref": 0}, {"heading": "Experimental Setup", "text": "We evaluate our model with Spider (Yu et al., 2018c), a large-scale, complex and cross-domain text-to-SQL dataset. We follow the same database split as Yu et al. (2018c), which ensures that any database schema that appears in the training set does not appear in the dev or test set. Through this split, we examine how well our model can be generalized to unseen databases. Because the test set is not opened to the public, we use the dev set for the ablation analysis. For the evaluation metrics, we use 1) accuracy of exact SQL matching and 2) F1 score of SQL component matching, proposed by (Yu et al., 2018c). We also follow their query hardness criteria to understand the model performance on different levels of queries. Our model and all the baseline models are trained based on only the Spider dataset without data augmentation.", "n_publication_ref": 3, "n_figure_ref": 0}, {"heading": "Model Configuration", "text": "We use the same hyperparameters for every module. For the word embedding, we apply deep contextualized word representations (ELMO) from Peters et al. (2018) and allow them to be fine-tuned during the training. For the question and column encoders, we use a 1-layer 512-unit bi-directional LSTM. For the decoders in the columns and operators prediction modules, we use a 1-layer 1024unit uni-directional LSTM. For the training, we use Adam optimizer (Kingma and Ba, 2014) with a learning rate of 1e-4 and use early stopping with 50 epochs. Additionally, we use dropout (Hinton et al., 2012) with a rate of 0.2 for the regularization.", "n_publication_ref": 2, "n_figure_ref": 0}, {"heading": "Result and Analysis", "text": "Table 1 shows the exact SQL matching accuracy of our model and previous models. We achieve 24.3% and 28.8% on the test and dev sets respectively, which outperforms the previous best model SyntaxSQLNet (Yu et al., 2018b) by 4.6% and 9.8%. Moreover, our model outperforms previous models on all different query hardness levels.\nTo examine how each technique contributes to the performance, we conduct an ablation analysis of three aspects: 1) without recursion, 2) without self-attention for database schema encoding, and 3) without sketch prediction modules that decide the number of decoding steps. Without recursive sub-query generation, the accuracy drops by 5.7% and 3.6% for hard and extra hard queries, respectively. This result shows that the recursion we use enables the model to predict nested queries. When using the final LSTM hidden state as in Yu et al. (2018b) instead of using self-attention for schema encoding, the accuracy drops by 4.0% on all queries. Finally, when using only an encoder-decoder architecture without sketch generation for columns prediction, the accuracy drops by 4.7%.\nFor the component matching result for each SQL clause, our model outperforms previous approaches for all of the SQL components by a significant margin, as shown in Table 2. Examples of predicted SQL from different models are shown in Appendix A.", "n_publication_ref": 2, "n_figure_ref": 0}, {"heading": "Conclusion", "text": "In this paper, we propose a recursive and SQL clause-wise decoding neural architecture to address the complex and cross-domain text-to-SQL task. We evaluate our model with the Spider dataset, and the experimental result shows that our model significantly outperforms previous work for generating not only simple queries, but also complex and nested queries.   (Yu et al., 2018b), and modified SQLNet (Xu et al., 2017) by Yu et al. (2018c), respectively.", "n_publication_ref": 3, "n_figure_ref": 0}, {"heading": "Acknowledgments", "text": "We thank Yongsik Lee, Jaesik Yoon, and Donghun Lee (SAP) for their reviews and support. We also thank professor Sungroh Yoon, Jongyun Song, and Taeuk Kim (Seoul National University) for their insightful feedback and three anonymous reviewers for their helpful comments.", "n_publication_ref": 0, "n_figure_ref": 0}, {"heading": "A Sample SQL Predictions", "text": "In Table 3, we show some examples of predicted SQL queries from different models. We compare the result of our model with two of previous state-of-the-art models: SyntaxSQLNet (Yu et al., 2018b) and the modified version of SQLNet (Xu et al., 2017) by Yu et al. (2018c) to support complex SQL queries.", "n_publication_ref": 3, "n_figure_ref": 0}], "references": [{"title": "Coarse-to-fine decoding for neural semantic parsing", "journal": "", "year": "2018", "authors": "Li Dong; Mirella Lapata"}, {"title": "Improving text-to-sql evaluation methodology", "journal": "", "year": "2018", "authors": "Catherine Finegan-Dollak; Jonathan K Kummerfeld; Li Zhang; Karthik Ramanathan; Sesh Sadasivam; Rui Zhang; Dragomir Radev"}, {"title": "Improving neural networks by preventing coadaptation of feature detectors", "journal": "", "year": "2012", "authors": "Nitish Geoffrey E Hinton; Alex Srivastava; Ilya Krizhevsky; Ruslan R Sutskever;  Salakhutdinov"}, {"title": "Natural language to structured query generation via metalearning", "journal": "", "year": "2018", "authors": "Po-Sen Huang; Chenglong Wang; Rishabh Singh; Wen-Tau Yih; Xiaodong He"}, {"title": "Learning a neural semantic parser from user feedback", "journal": "", "year": "2017", "authors": "Srinivasan Iyer; Ioannis Konstas; Alvin Cheung; Jayant Krishnamurthy; Luke Zettlemoyer"}, {"title": "Mapping language to code in programmatic context", "journal": "", "year": "2018", "authors": "Srinivasan Iyer; Ioannis Konstas; Alvin Cheung; Luke Zettlemoyer"}, {"title": "Adam: A method for stochastic optimization", "journal": "", "year": "2014", "authors": "P Diederik; Jimmy Kingma;  Ba"}, {"title": "One-shot learning for text-to-sql generation", "journal": "", "year": "2019", "authors": "Dongjun Lee; Jaesik Yoon; Jongyun Song; Sanggil Lee; Sungroh Yoon"}, {"title": "A structured self-attentive sentence embedding", "journal": "", "year": "2017", "authors": "Zhouhan Lin; Minwei Feng; Cicero Nogueira; Mo Santos; Bing Yu; Bowen Xiang; Yoshua Zhou;  Bengio"}, {"title": "Effective approaches to attention-based neural machine translation", "journal": "", "year": "2015", "authors": "Thang Luong; Hieu Pham; Christopher D Manning"}, {"title": "Deep contextualized word representations", "journal": "", "year": "2018", "authors": "Matthew Peters; Mark Neumann; Mohit Iyyer; Matt Gardner; Christopher Clark; Kenton Lee; Luke Zettlemoyer"}, {"title": "Evaluation of spoken language systems: The atis domain", "journal": "", "year": "1990-06-24", "authors": "J Patti;  Price"}, {"title": "Abstract syntax networks for code generation and semantic parsing", "journal": "Long Papers", "year": "2017", "authors": "Maxim Rabinovich; Mitchell Stern; Dan Klein"}, {"title": "Sqlnet: Generating structured queries from natural language without reinforcement learning", "journal": "", "year": "2017", "authors": "Xiaojun Xu; Chang Liu; Dawn Song"}, {"title": "What it takes to achieve 100% condition accuracy on wikisql", "journal": "", "year": "2018", "authors": "Semih Yavuz; Izzeddin Gur; Yu Su; Xifeng Yan"}, {"title": "A syntactic neural model for general-purpose code generation", "journal": "Long Papers", "year": "2017", "authors": "Pengcheng Yin; Graham Neubig"}, {"title": "Typesql: Knowledgebased type-aware neural text-to-sql generation", "journal": "", "year": "2018", "authors": "Tao Yu; Zifan Li; Zilin Zhang; Rui Zhang; Dragomir Radev"}, {"title": "Syntaxsqlnet: Syntax tree networks for complex and cross-domain text-to-sql task", "journal": "", "year": "2018", "authors": "Tao Yu; Michihiro Yasunaga; Kai Yang; Rui Zhang; Dongxu Wang; Zifan Li; Dragomir Radev"}, {"title": "Spider: A large-scale human-labeled dataset for complex and cross-domain semantic parsing and text-to-sql task", "journal": "", "year": "2018", "authors": "Tao Yu; Rui Zhang; Kai Yang; Michihiro Yasunaga; Dongxu Wang; Zifan Li; James Ma; Irene Li; Qingning Yao; Shanelle Roman"}, {"title": "Learning to parse database queries using inductive logic programming", "journal": "", "year": "1996", "authors": "M John; Raymond J Zelle;  Mooney"}, {"title": "Seq2sql: Generating structured queries from natural language using reinforcement learning", "journal": "CoRR", "year": "2017", "authors": "Victor Zhong; Caiming Xiong; Richard Socher"}, {"title": "Attentionbased bidirectional long short-term memory networks for relation classification", "journal": "Short Papers", "year": "2016", "authors": "Peng Zhou; Wei Shi; Jun Tian; Zhenyu Qi; Bingchen Li; Hongwei Hao; Bo Xu"}], "figures": [{"figure_label": "1", "figure_type": "", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: Clause-wise and recursive SQL generation process.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Accuracy of exact SQL matching with different hardness levels.", "figure_data": "MethodSELECT WHERE GROUP BY ORDER BY KEYWORDSSQLNet46.6%20.6%37.6%49.2%62.8%TypeSQL43.7%14.8%16.9%52.1%67.0%SyntaxSQLNet55.4%22.2%51.4%50.6%73.3%Ours68.7%39.0%63.1%63.5%76.5%"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "F1 scores of SQL component matching on the dev set.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "names of all the countries that became independent after 1950? Truth SELECT Name FROM country WHERE IndepYear > 1950 Ours SELECT Name FROM country WHERE IndepYear > \"[VAR]\" Syntax SELECT Name FROM country WHERE GovernmentForm = \"[VAR]\" SQLNet SELECT T1.Name FROM city as T1 JOIN country as T2 WHERE T2.Population > \"[VAR]\" medium NL Which city and country is the Alton airport at? Truth SELECT City, Country FROM airports WHERE AirportName = \"Alton\" Ours SELECT City, Country FROM airports WHERE AirportName = \"[VAR]\" Syntax SELECT Country, City FROM airports WHERE Country = \"[VAR]\" SQLNet SELECT T1.City, T2.DestAirport FROM airports as T1 JOIN flights as T2 medium NL List the names of poker players ordered by the final tables made in ascending order. Truth SELECT T1.Name FROM people as T1 JOIN poker player as T2 ORDER BY T2.Final Table Made Ours SELECT T1.Name FROM people as T1 JOIN poker player as T2 ORDER BY T2.Final Table Made ASC Syntax SELECT T2.Name FROM poker player as T1 JOIN people as T2 ORDER BY T1.Earnings ASC SQLNet SELECT Name FROM people ORDER BY Birth Date ASC medium NL How much does the most recent treatment cost? Truth SELECT cost of treatment FROM Treatments ORDER BY date of treatment DESC LIMIT 1 Ours SELECT cost of treatment FROM Treatments ORDER BY cost of treatment DESC LIMIT \"[VAR]\" Syntax SELECT cost of treatment FROM Treatments ORDER BY cost of treatment ASC LIMIT \"[VAR]\" SQLNet SELECT T1.charge amount FROM Charges as T1 JOIN Dogs as T2 ORDER BY date adopted DESC LIMIT \"[VAR]\" hard NL List the names of teachers who have not been arranged to teach courses. Truth SELECT Name FROM teacher WHERE Teacher id NOT IN (SELECT Teacher id FROM course arrange) Ours SELECT Name FROM teacher WHERE Teacher id NOT IN (SELECT Teacher id FROM course arrange) Syntax SELECT Name FROM teacher SQLNet SELECT Name FROM teacher hard NL Which cities do more than one employee under age 30 come from? Truth SELECT city FROM employee WHERE age < 30 GROUP BY city HAVING count(*) > 1 Ours SELECT city FROM employee WHERE age < \"[VAR]\" GROUP BY city HAVING count(*) > \"[VAR]\" Syntax SELECT city FROM employee WHERE age > \"[VAR]\" SQLNet SELECT T1.city FROM employee as T1 JOIN hiring as T2 JOIN shop as T3 WHERE T3.District > \"[VAR]\" GROUP BY T1.city HAVING count(*) > \"[VAR]\" hard NL What is the document id with least number of paragraphs? Truth SELECT document id FROM Paragraphs GROUP BY document id ORDER BY count(*) LIMIT 1 Ours SELECT document id FROM Documents GROUP BY document id ORDER BY count(*) ASC LIMIT \"[VAR]\" Syntax SELECT document id FROM Documents GROUP BY document id ORDER BY count(*) ASC LIMIT \"[VAR]\" HAVING count(*) >= \"[VAR]\" SQLNet SELECT template id FROM Templates GROUP BY template id HAVING sum(*) NOT \"[VAR]\" ORDER BY count(*) ASC LIMIT \"[VAR]\" extra NL How many dogs have not gone through any treatment? Truth SELECT count(*) FROM Dogs WHERE dog id NOT IN (SELECT dog id FROM Treatments) Ours SELECT count(*) FROM Dogs WHERE dog id NOT IN (SELECT dog id FROM Treatments) Syntax SELECT count(*) FROM Charges WHERE charge id NOT IN (SELECT charge id FROM Charges) SQLNet SELECT count(*) FROM Dogs WHERE dog id IN \"[VAR]\" extra NL What is the name of the high schooler who has the greatest number of friends? Truth SELECT T2.name FROM Friend as T1 JOIN Highschooler as T2 GROUP BY T1.student id ORDER BY count(*) DESC LIMIT 1 Ours SELECT T1.name FROM Highschooler as T1 JOIN Friend as T2 GROUP BY T2.student id ORDER BY count(*) DESC LIMIT 1 Syntax SELECT name FROM Highschooler ORDER BY grade DESC LIMIT 1 SQLNet SELECT T1.name FROM Friend as T1 JOIN Friend as T2 GROUP BY T2.student id ORDER BY * DESC LIMIT 1", "figure_data": "hardness typedescriptioneasyNLWhat are the"}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "Sample SQL predictions by our model and previous state-of-the-art models on the dev split. NL denotes the natural language question and Truth denotes the corresponding ground truth SQL query. Ours, Syntax, and SQLNet denotes the SQL predictions from our model, SyntaxSQLNet", "figure_data": ""}], "doi": ""}